#!/usr/bin/env perl

# Use perldoc or option --man to read documentation

########################################################################
# MODULES
########################################################################

# Include core modules.
use strict;
use warnings;
use File::Basename;
use Carp;
use POSIX;

# Include CPAN modules.
use Getopt::Euclid qw{ :vars<opt_> };
use Readonly;
use Audio::FLAC::Header;

# Include private modules.
use What::Discogs;
use What::Utils;
use What::WhatRC;
use What::Prompt;

########################################################################
# GENERAL GLOBAL VARIABLES
########################################################################

# Basic program information.
Readonly my $prog_incantation  => $0;
Readonly my $prog_dir          => dirname($0);
Readonly my $prog_name         => basename($0);

# Command-line option hash.
my %opt = %ARGV;

# Global program exitcode.
my $exitcode = 0;

########################################################################
# PROGRAM SPECIFIC GLOBALS
########################################################################

my $whatrc = read_whatrc('~/.whatrc');
my $prompt = What::Prompt->new();

########################################################################
# MAIN FUNCTION
########################################################################

# main() - main program execution 
sub main{
    # Find all the disc directories/FLAC files.
    my @rip_files = find_hierarchy($whatrc->{rip_dir});
    my @flac_files = grep {$_ =~ / \.flac \z/xms} @rip_files;
    my %disc = map {($_ ? (dirname($_) => {}) : ())} @flac_files;
    my @disc_dirs = sort keys %disc;
    my @disc_folder_names = map {basename($_)} @disc_dirs;

    # Find info about all the present discs.
    my $release_artist;
    my $release_title;
    my $release_year;
    my $release_label;
    my $release_catno;
    my $release_format;
    my $release_edition;
    for my $disc_dir (keys %disc) {
        print {\*STDERR} $disc_dir, "\n";
        next if !defined $disc_dir || !-d $disc_dir;
        # Get the song files.
        my @disc_files = find_file_pattern('*.flac', $disc_dir);
        @disc_files = sort @disc_files;
        croak("No FLAC files found in $disc_dir. This is unexpected...\n")
            if (!@disc_files);

        # Help subroutine to parse track position from the filename.
        my $get_position_from_file = sub {
                my $file = basename(shift); 
                $file =~ s/(\s | -) .* \z//xms; 
                return $file; };

        my @tracks;
        my $disc_artist;
        my $disc_title;
        my $disc_year;
        # Read the tags of each song.
        for my $song (@disc_files) {
            my $info = Audio::FLAC::Header->new($song);
            my %tags = %{$info->{tags}};

            # Fetch the important tags.
            my $pos = $get_position_from_file->($song);
            my $title = $tags{TITLE} || $tags{title};
            my $artist = $tags{ARTIST} || $tags{artist};
            my $album_artist = $tags{ALBUMARTIST} || $tags{albumartist};
            my $date = $tags{date} || $tags{DATE};
            my $year;
            if ($date =~ m/(\d{4})/xms) {
                $year = $1;
            }
            else {
                print {\*STDERR}
                    "Warning: Can't find year in release\n";
            }
            my $release_title = $tags{ALBUM} || $tags{album};
            if (defined $album_artist) { 
                $disc_artist = $album_artist if (!defined $disc_artist);
                if (not $disc_artist eq $album_artist) {
                    print {\*STDERR} 
                        "Inconsistency: ",
                        "Album artist ($album_artist vs $release_artist)\n";
                }
            }

            # find the track duration.
            my $dur = $info->{trackTotalLengthSeconds};

            # Construct a 'track object'.
            my %track = (
                artist => $artist,
                (defined $album_artist ? (album_artist => $album_artist) : ()),
                release => $release_title,
                position => $pos,
                duration => $dur,
                year => $year,
                title   => $title,);
            push @tracks, \%track;
        }

        # Find an artist for the disc.
        if (!defined $disc_artist) {
            my @artists = map {$_->{artist}} @tracks;
            if (all_equal(@artists)) {
                $disc_artist = $artists[0];
            }
            else {
                $disc_artist = common_prefix(@artists);
            }
            if (!defined $disc_artist || 0 == length $disc_artist) {
                $disc_artist = "Various Artists";
            }
        }

        # Find a title for the disc.
        my @release_titles = map {$_->{release}} @tracks;
        if (all_equal(@release_titles)) {
            $disc_title = $release_titles[0];
        }
        else {
            croak("Inconsistency: "
                . "Album tag for files of "
                . basename($disc_dir) . ".");
        }

        # Find a year for the disc.
        my @years = map {$_->{year}} @tracks;
        if (!all_equal(@years)) {
            croak("Inconsistency: Years for disc "
                . basename($disc_dir) . ".");
        }
        $disc_year = $years[0];

        # Create a 'disc' object.
        my %disc_info = (
            title => $disc_title,
            artist => $disc_artist,
            year => $disc_year,
            tracks => \@tracks,);
        $disc{$disc_dir} = \%disc_info;
    }

    # Figure out the year of the whole release.
    my @disc_years = map {$_->{year}} values %disc;
    if (!all_equal(@disc_years)) {
        croak("Inconsistency: Varying disc years.")
    }
    $release_year = $disc_years[0];

    # Figure out the title for the whole release.
    my @disc_titles = map {$_->{title}} values %disc;
    if (!all_equal(@disc_titles)) {
        $release_title = common_prefix(@disc_titles);
    }
    else {
        $release_title = $disc_titles[0];
    }
    if (!defined $release_title || 0 == length $release_title) {
        croak("Couldn't find a release title common to all discs.");
    }

    # Find the artist for the whole release.
    my @disc_artists = map {$_->{artist}} values %disc;
    if (!all_equal(@disc_artists)) {
        my @non_various = grep {$_ !~ /Various(?:\sArtists)?/ixms} @disc_artists;
        if (all_equal(@non_various) && @non_various > 0) {
            $release_artist = $non_various[0];
        }
        elsif (@non_various > 0) {
            if (all_equal(@non_various)) {
                # All the discs by a single artist are by the same artist.
                # That artist is probably the release artist
                # TODO: Prompt user to make sure.
                $release_artist = $non_various[0];
            }
            else {
                # Multiple discs produced by a single artist.
                # However, not all the disc artists are the same.
                
                # Attempt to salvage
                $release_artist = common_prefix(@non_various);
                if ($release_artist == '') {
                    # TODO: Prompt user about which artists to use.
                    $release_artist = 'Various Artists';
                }
                else {
                    # If each disc is featuring other artsists, 
                    #  hopefully they got filtered.
                    # TODO: Prompt user to make sure $release_artist is good.
                }
            }
        }
        else {
            # Looks like all the discs are by various artists
            # TODO: Prompt user to make sure.
            $release_artist = "Various Artists";
        }
    }
    else {
        # In this case, all discs are by the same artist.
        $release_artist = $disc_artists[0];
    }

    print "I think that this release should be labelled...\n";
    print "$release_artist - $release_title [$release_year]\n";

    #-------------------------#
    # BEGIN SEARCHING DISCOGS #
    #-------------------------#
    my $release; # A pointer to the release when we find it.
    if ($release_artist eq "Various Artists") {
        # TODO: Do is a release search.
    }
    else {
        # TODO: First, try an artist search.
        # TODO: When unsuccessful w/ artist search; try a release search.
    }
    # TODO: When Discogs search fails, search Musicbrainz if possible.

    # When the all searches failed to find a release. 
    if (!defined $release) {
        # TODO: Ask the user for a musicbrainz release identifier.
        # Ask the user for a discogs release id 
        $prompt->text('Enter a discogs release ID (check format/edition):');
        $prompt->validator(sub {my $id = shift; $id =~ m/\A \d* \z/xms});
        my $discogs_id = $prompt->prompt_user();
        chomp $discogs_id;
        $release = get_release(
                id => $discogs_id, 
                api => $whatrc->{discogs_api_key})
            if $discogs_id =~ m/\d+/xms;

        my $is_consistent 
            = release_agrees(
                release => $release, 
                title => $release_title,
                artist => $release_artist,
                year => $release_year,
                discs => [values %disc],);
        if (!$is_consistent) {
            # Die if the discsogs release is not conistent with the files.
            print {\*STDERR} "Inconsistent release info and tag info.\n";
            exit 1;
        }
    }

    
    if (defined $release) {
        # TODO: Handle a Musicbrainz release.
        $release_label = join ", ", (map {$_->name()} @{$release->labels()});
        $release_catno = join ", ", (map {$_->catno()} @{$release->labels()});
        $release_format
            = join ", ",
                (map {$_->quantity() > 1 ? 
                        $_->quantity() ."x".$_->type()
                        : $_->type() }
                    @{$release->formats()});
        $release_edition 
            = join ", ",
                (map {join " ", @{$_->descriptions()}} @{$release->formats()});
    }
    else {
        # When the user can't find a release id, create info from tags.
        print "'Manual' info creation...\n";
        # Prompt user for label and catno.
        $prompt->text("Enter the label:");
        $prompt->validator(sub {my $r = shift; chomp $r; $r =~ /.\z/xms});
        $release_label = $prompt->prompt_user();
        $prompt->text("Enter the category number (on CD side):");
        $release_catno = $prompt->prompt_user();
        $prompt->text("Enter any edition information(none for original release):");
        $prompt->reset_validator();
        $release_edition = $prompt->prompt_user();
        if ($release_edition =~ s/\A \s*\n? \z//xms) {
            $release_edition = "Original Release";
        }
    }

    my $info =<<EOIHEAD;
Title.........$release_title
Artist........$release_artist
Edition.......$release_edition
Released......$release_year 
Label.........$release_label
Category No...$release_catno

EOIHEAD

    for my $disc_d (@disc_dirs) {
        if (@disc_dirs > 1) {
            my $disc_name = basename($disc_d);
            $info .= "$disc_name\n";
        }

        my $disc = $disc{$disc_d};
        my @tracks = @{$disc->{tracks}};
        for my $track (@tracks) {
            my $dur = $track->{duration};
            my ($min, $sec) = (floor($dur / 60), floor($dur % 60));
            $info .= "$track->{position} $track->{title} [$min:$sec]";
            if ($release_artist eq 'Various Artists') {
                $info .= " ($track->{artist})";
            }
            $info .= "\n";
        }

        if (@disc_dirs > 1) {
            $info .= "\n";
        }
    }

    print $info;

    exit $exitcode;
}

########################################################################
# SUPPORTING SUBROUTINES
########################################################################

# Subroutine: release_agrees(
#   release => $release, 
#   artist => $artist,
#   title => $title,
#   year => $edition_year,
#   discs => \@discs)
# Type: INTERNAL UTILITY
# Purpose: Check a discogs release, and given release info for consistency.
# Returns:
#   1 if the discogs release contains consistent release information.
#   0 otherwise.
sub release_agrees {
    my %arg = @_;
    my $release = $arg{release};
    return 
        release_title_agrees($release, $arg{title}) 
        && release_artist_agrees($release, $arg{artist}) 
        && release_year_agrees($release, $arg{year})
        && release_discs_agree($release, $arg{discs});
}

# Release test template.
# Subroutine: release_xxxx_agrees($discogs_release, $release_xxxx)
# Type: INTERNAL UTILITY
# Purpose: Compare the xxxx of a discogs release to a given string.
# Returns: 
#   1 if the title of the discogs release is equal to $release_xxxx.
#   0 otherwise.
#sub release_xxxx_agrees {
#    return 0;
#}

# Subroutine: release_title_agrees($discogs_release, $release_title)
# Type: INTERNAL UTILITY
# Purpose: Compare the title of a discogs release to a given string.
# Returns: 
#   1 if the title of the discogs release is equal to $release_title.
#   0 otherwise.
sub release_title_agrees {
    my ($release, $title) = @_;
    return 1 if ($release->title() eq $title);
    return 0;
}

# Subroutine: release_year_agrees($discogs_release, $release_year)
# Type: INTERNAL UTILITY
# Purpose: Compare the year of a discogs release to a given string.
# Returns: 
#   1 if the title of the discogs release is equal to $release_year.
#   0 otherwise.
sub release_year_agrees {
    my ($release, $year) = @_;
    my $date = $release->date();
    return 1;
}

# Subroutine: release_discs_agree($discogs_release, \@discs)
# Type: INTERNAL UTILITY
# Purpose: 
#   Attempt to match of the the release to an array of discs' info.
#   For now, a simple 'down-the-line' test of agreement for each disc.
# Returns: 
#   1 if the discs of the discogs release \@discs.
#   0 otherwise.
sub release_discs_agree {
    my $release = shift;
    my @discs = @{shift @_};
    return 0 if $release->num_discs != scalar @discs;
    for my $i (0 .. $#discs) {
        my $di = $discs[$i];
        my $rel_di = $release->disc($i + 1);
        return 0 if !disc_tracks_agree($rel_di, $di->{tracks});
    }
    return 1;
    # TODO: Implement this method as a permutation search. 
    #   There is not necessarily a guaranteed ordering.
}

# Subroutine: disc_tracks_agree($disc, \@tracks)
# Type: INTERNAL UTILITY
# Purpose: 
#   Compare the tracks of a discogs release's disc to a given array of track info.
# Returns: 
#   1 if the tracks of the disc agree with $release_tracks.
#   0 otherwise.
sub disc_tracks_agree {
    my ($release, $tracks_ref) = @_;
    my @rel_tracks = @{$release->tracks()};
    my @tracks = @{$tracks_ref};

    # Return false if the number of tracks differ.
    return 0 if (@{$release->tracks} != @tracks);

    # Iterate over corresponding tracks.
    for my $i (0 .. $#tracks) {
        my ($rel_ti, $ti) = ($rel_tracks[$i], $tracks[$i]);

        # Find the duration of the discogs track in seconds.
        my $rel_dur = $rel_ti->duration();
        if ($rel_dur =~ m/(\d+):(\d{2})/xms) {
            $rel_dur = 60 * $1 + $2;
        }
        # Return false if discogs duration is more than the possed duration.
        return 0 if $rel_dur > $ti->{duration};
    }
    # Track names might be subtly misspelled. Are not checked currently.

    # No reason can be found for the tracks to disagree.
    return 1;
}

# Subroutine: release_artist_agrees($discogs_release, $release_artist)
# Type: INTERNAL UTILITY
# Purpose: Compare the artist of a discogs release to a given string.
# Returns: 
#   1 if the title of the discogs release is equal to $release_artist.
#   0 otherwise.
sub release_artist_agrees {
    my ($release, $artist) = @_;
    for my $a (@{$release->artists()}) {
        return 0 if index ($artist, $a->name) == -1;
        $a =~ s/\AThe\s+(\S.*\S)\z/$1, The/xms;
        return 0 if index ($artist, $a->name) == -1;
    }
    return 1;
}

# Subroutine: all_equal(@strings)
# Type: INTERNAL UTILITY
# Purpose: Check if all strings in a list are equal.
# Returns: True if all the strings are the same.
sub all_equal {
    my @strings = @_;
    my $last;
    for my $str (@strings) {
        if (!defined $last) {
            $last = $str;
        }
        else {
            return if not $last eq $str;
        }
    }
    return 1;
}

# Subroutine: common_prefix(@strings)
# Type: INTERNAL UTILITY
# Purpose: Find the longest prefix string common to a list.
# Returns: 
#   Returns the longest prefix string. 
#   If no non-trivial prefix exists then an empty string is returned.
sub common_prefix {
    my @strings = @_;
    my $prefix = shift @strings || '';
    for my $s (@strings) { $prefix = common_prefix_pair($prefix, $s) }
    return $prefix;
}

# Subroutine: suffixes(@strings)
# Type: INTERNAL UTILITY
# Purpose: Remove the common prefix from all argument strings.
# Returns: A list of strings with the common prefix removed.
sub suffixes {
    my @strings = @_;
    my $prefix = common_prefix(@strings);
    my $rm_len = length $prefix;
    map {substr $_, 0, $rm_len, q()} @strings;
    return @strings;
}


# Subroutine: common_prefix_pair($s1, $s2)
# Type: INTERNAL UTILITY
# Purpose: Find the longest prefix string common to strings $s1 and $s2.
# Returns: 
#   Returns the longest prefix string. 
#   If no non-trivial prefix exists then an empty string is returned.
sub common_prefix_pair {
    my ($s1, $s2) = @_;
    my ($len1, $len2) = map {length $_} ($s1, $s2);
    my $max_len = $len1 > $len2 ? $len1 : $len2;
    my $prefix = '';
    for my $i (0 ... $max_len - 1) {
        my ($sub1, $sub2) = map {substr $_, $i, 1} ($s1, $s2);
        if ($sub1 eq $sub2) {
            $prefix .= $sub1;
        }
        else {
            last;
        }
    }
    return $prefix;
}

# Finally, kickstart the script
main();

__END__

=head1 NAME

release-mkinfo
-- short description

=head1 VERSION

Version 0.0_1
Originally created on 10/10/10 17:43:36

=head1 USAGE

release-mkinfo [options]

=head1 REQUIRED ARGUMENTS

=over

=item --artist [=] <artist>

Release artist.

=item --title [=] <title>

Release title.

=item --year [=] <year>

Release year.

=back

=head1 OPTIONS

=over

=item --version

=item --usage

=item --help

=item --man

Print the usual program information

=back

=head1 DESCRIPTION

Search for latest rip in online databases and create a release description 
(.nfo file).

=head1 BUGS

=over

=back

=head1 AUTHOR & COPYRIGHT 

©Bryan Matsuo (bryan.matsuo@gmail.com)

