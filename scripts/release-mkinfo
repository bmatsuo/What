#!/usr/bin/env perl

# Use perldoc or option --man to read documentation

########################################################################
# MODULES
########################################################################

# Include core modules.
use strict;
use warnings;
use File::Basename;
use Carp;
use POSIX;

# Include CPAN modules.
use Data::Dumper;
use Getopt::Euclid qw{ :vars<opt_> };
use Audio::FLAC::Header;
use Exception::Class (
    'TrackException',
    'TrackTotalException' => { isa => 'TrackException' },
    'TrackDurationException' => { isa => 'TrackException' },
);

# Include private modules.
use What::Subsystem;
use What::Discogs;
use What::Utils;
use What::WhatRC;
use What::BBCode;
use What::Prompt;
use What::Prompt::Choose;
use What::Prompt::YesNo;

########################################################################
# GENERAL GLOBAL VARIABLES
########################################################################

# Basic program information.
my $prog_incantation  = $0;
my $prog_dir          = dirname($0);
my $prog_name         = basename($0);

# Command-line option hash.
my %opt = %ARGV;

# Global program exitcode.
my $exitcode = 0;

########################################################################
# PROGRAM SPECIFIC GLOBALS
########################################################################

my %checked_release;
my %checked_artist;

my $prompt = What::Prompt->new();
my $subsystem = What::Subsystem->new(
    verbose => $opt{'--verbose'},
    dry_run => $opt{'-dry_run'});

my $known_miss_char = 'x';
my $miss_char = '.';
my $near_miss_char = '_';
my $close_char = '-';
my $hit_char = '*';

########################################################################
# MAIN FUNCTION
########################################################################

# main() - main program execution 
sub main{
    my @nfos = find_file_pattern('*.nfo', whatrc->rip_dir);
    my $bbinfo_filename = "Info.txt";
    my $generate_info = 1;
    my $generate_bbinfo = 1;
    my $fetch_image = !has_images(whatrc->rip_dir);
    my $bbinfo_path = whatrc->rip_dir."/$bbinfo_filename";
    if (@nfos) {
        my $err = "Info file exists at @nfos.";
        if ($opt{'--skip-existing'}) {
            print "$err\n" if $opt{'--verbose'};
            $generate_info = 0
        }
        else{
            die $err;
        }
    }
    if (-e $bbinfo_path) {
        my $err = "BBCode Info.txt exists at $bbinfo_path.";
        if ($opt{'--skip-existing'}) {
            print "$err\n" if $opt{'--verbose'};
            $generate_bbinfo = 0
        }
        else{
            die $err;
        }
    }
    if ( !($generate_info || $generate_bbinfo || $fetch_image) ) {
        print "Nothing to fetch from online databases.\n";
        exit 0;
    }

    #-------------------#
    # ANALYZE FILE TAGS #
    #-------------------#
    my $r = analyze_release(whatrc->rip_dir);

    my @disc_dirs = @{$r->{discs}};
    my %disc = %{$r->{disc_info}};
    my $release_artist = $r->{artist};
    my $release_title = $r->{title};
    my $release_year = $r->{year};
    my $release_date = $release_year;

    print "Presumed release title: ";
    print "$release_artist - $release_title [$release_year]\n";

    my $release_country;
    my $release_label;
    my $release_catno;
    my $release_format;
    my $release_edition;
    my $release_type = q{};

    #-------------------------#
    # BEGIN SEARCHING DISCOGS #
    #-------------------------#
    my $release; # A pointer to the release when we find it.
    my @artists_checked;
    if (not $release_artist eq "Various Artists"){
        #---------------------#
        # ARTIST-BASED SEARCH #
        #---------------------#

        # First, try an artist query.
        print "Trying default artist page ";
        $checked_artist{$release_artist} = 1;
        $release = find_release_in_artist_page(
            artist => $release_artist,
            title => $release_title,
            year => $release_year,
            discs => [values %disc]);

        if (!defined $release) {
            print "Searching by artist name ... ";
            my $artist_search_results = search(
                qstr => $release_artist, 
                type => 'artist', 
                api => whatrc->discogs_api_key);
            my $matching_result_list 
                = $artist_search_results->grep(
                    sub {my $a = shift;  
                        my $no_copy_num = $a->title;
                        $no_copy_num =~ s/\s+[(]\d+[)]\z//xms;
                        $a->type eq 'artist'
                        && !$checked_artist{$a->title} 
                        && align($no_copy_num, $release_artist) > 0.83});
            my $num_matches = $matching_result_list->num_results;
            print "Found $num_matches (new) matching artists.\n";
            if ( $num_matches > 0) {
                SEARCHARTISTRESULTS:
                for my $r (@{$matching_result_list->results()}) {
                    print "Searching discography of " . $r->title;
                    $release = find_release_in_artist_page(
                        artist => $r->title,
                        title => $release_title,
                        year => $release_year,
                        discs => [values %disc]);
                    $checked_artist{$r->title} = 1;
                    last SEARCHARTISTRESULTS if defined $release;
                }
            }
        }
    }

    if (!defined $release) {
        #------------------------#
        # GERENAL RELEASE SEARCH #
        #------------------------#

        # Either artist search failed or artist is "Various Artists"
        print {\*STDERR} "Attempting general search ";
        my $release_search = search (
            qstr => $release_artist eq "Various Artists" ? $release_title 
                : "$release_artist - $release_title",
            type => 'release',
            api => whatrc->discogs_api_key,);
        $release = find_release_in_search_results(
            results => $release_search,
            artist => $release_artist,
            title => $release_title,
            year => $release_year,
            discs => [values %disc]);
        if (!$release 
                && $release_artist eq "Various Artists" 
                && $release_title =~ m/\A(.+):.*\z/xms) {
            my $main_title = $1;
            print "Attempting even more general search";
            $release_search = search (
                qstr => $main_title,
                type => 'release',
                api => whatrc->discogs_api_key,);
            $release = find_release_in_search_results(
                results => $release_search,
                artist => $release_artist,
                title => $release_title,
                year => $release_year,
                discs => [values %disc]);
        }
    }
    # TODO: When Discogs search fails, search Musicbrainz if possible.

    # When the all searches failed to find a release. 
    if (!defined $release) {
        # TODO: Ask the user for a musicbrainz release identifier.
        # Ask the user for a discogs release id 
        $prompt->text('Enter a discogs release ID (check format/edition):');
        $prompt->validator(sub {my $id = shift; $id =~ m/\A \d* \z/xms});
        my $discogs_id = $prompt->prompt_user();
        chomp $discogs_id;
        $release = get_release(
                id => $discogs_id, 
                api => whatrc->discogs_api_key)
            if $discogs_id =~ m/\d+/xms;

        if (defined $release) {
            my @conflicts = release_conflicts(
                    release => $release, 
                    title => $release_title,
                    artist => $release_artist,
                    year => $release_year,
                    discs => [values %disc],);
            if (@conflicts) {
                # Die if the discsogs release is not conistent with the files.
                print {\*STDERR} "Inconsistent release info and tag info.\n",
                    join ("\n", @conflicts);

                exit 1;
            }
        }
    }
    
    
    #-----------------------#
    # STRINGIFY INFO PIECES #
    #-----------------------#
    if (defined $release) {
        # TODO: Handle a Musicbrainz release.
        if (defined $release->date) {
            $release_date = $release->date;
            if ($release_date =~ m/(\d{4})/xms) {
                $release_year = $1;
            }
        }
        $release_label = $release->label_string();
        $release_catno = $release->catno_string();
        $release_format
            = join ":",
                (map {  ( $_->quantity() > 1 ?  $_->quantity() ."x".$_->type()
                            : $_->type()) 
                        . (join q{, }, @{$_->descriptions()})}
                    @{$release->formats()});
        $release_edition 
            = join ", ",
                (map {join " ", @{$_->descriptions()}} @{$release->formats()});
        if ($release_edition 
                =~ s/(?: \A | \s ) ( Soundtrack | Compilation | Anthology | Album | EP | Single ) (?:\s | \z)//igxms) {
            $release_type = $1
        }
        $release_country = $release->country || q{};
    }
    else {
        # When the user can't find a release id, create info from tags.
        print "'Manual' info creation...\n";
        # Prompt user for label and catno.
        $prompt->reset_validator();
        $prompt->text("Enter a release type (Album, EP, Compilation, ...):");
        $release_type= $prompt->prompt_user();
        $prompt->text("Enter the label if any:");
        $release_label = $prompt->prompt_user();
        $prompt->text("Enter the category number if any (on CD side):");
        $release_catno = $prompt->prompt_user();
        $prompt->text(
            "Enter any extra edition info (e.g. 'Deluxe', 'Remaster', etc.):"
        );
        $release_edition = $prompt->prompt_user();
        $prompt->text("Enter the country country of the release:");
        $release_country = $prompt->prompt_user();
    }
    #if ($release_edition =~ s/\A \s*\n? \z//xms) {
    #    $release_edition = "Original Release";
    #    if (defined $release_country) {
    #        $release_edition .= " ($release_country)";
    #    }
    #}

    #---------------#
    # GENERATE INFO #
    #---------------#

    my $info =<<EOIHEAD;
Title.........$release_title
Artist........$release_artist
Type..........$release_type
Edition info..$release_edition
Released......$release_date 
Countries.....$release_country
Label.........$release_label
Catno.........$release_catno

EOIHEAD

    my $bbrelease = bbcode->size( 
        scale => 3, 
        text => bbcode->artist(name => $release_artist));
    $bbrelease 
        = join q{ }, 
        $bbrelease, '-',
        bbcode->size(
            scale => 4,
            text => $release_title),
        "";
    $bbrelease = bbcode->bold(text=>$bbrelease);
    $bbrelease .= bbcode->size(
            scale => 3,
            text => "[$release_year]");
    $bbrelease = bbcode->align(
        justify => 'center',
        text => $bbrelease);

    my $bbinfo = "$bbrelease\n";

    $bbinfo 
        .= join q{ }, 
            $release_label, 
            "(", $release_country, $release_date,
            '|', $release_format, 
            '|', $release_catno,
            "):\n";
    my $bbtrack_format # requires args %s, %s, %d, %02d
        = join q{ }, 
            bbcode->bold(text => "%s. "), 
            "%s", "[%d:%02d]";

    for my $disc_d (@disc_dirs) {
        if (@disc_dirs > 1) {
            my $disc_name = basename($disc_d);
            $info .= "$disc_name\n";
            $bbinfo .= bbcode->bold(text=>$disc_name)."\n";
        }

        my $disc = $disc{$disc_d};
        my @tracks = @{$disc->{tracks}};
        for my $track (@tracks) {
            my $dur = $track->{duration};
            my ($min, $sec) = (floor($dur / 60), floor($dur % 60));
            $info .= sprintf "%s %s [%d:%02d]",
                $track->{position}, $track->{title}, $min, $sec;
            $bbinfo .= sprintf $bbtrack_format, 
                $track->{position}, $track->{title}, $min, $sec;
            if ($release_artist eq 'Various Artists') {
                $info .= " ($track->{artist})";
                $bbinfo .= " (" . bbcode->artist(name => $track->{artist}) . ")";
            }
            $info .= "\n";
            $bbinfo .= "\n"
        }

        if (@disc_dirs > 1) {
            $info .= "\n";
            $bbinfo .= "\n";
        }
    }

    #-------------#
    # OUTPUT INFO #
    #-------------#
    my $info_filename = "$release_artist - $release_title ($release_year).nfo";
    $info_filename =~ s![/:]!_!gxms;
    my $info_path = whatrc->rip_dir."/$info_filename";

    if ($generate_info) {
        open my $ifh, ">", $info_path
            or die "couldn't open $info_path.";
        print {$ifh} $info;
        close $ifh;
    }

    if ($generate_bbinfo) {
        open my $bbfh, ">", $bbinfo_path
            or die "couldn't open $bbinfo_path.";
        print {$bbfh} $bbinfo;
        close $bbfh;
    }

    fetch_cover_art($release) if defined $release;

    exit $exitcode;
}

########################################################################
# SUPPORTING SUBROUTINES
########################################################################

### INTERNAL UTILITY
# Subroutine: analyze_release
# Usage: analyze_release( $release_path )
# Purpose: 
# Returns: A hash of the following form.
#   (   artist => $artist,
#       title => $title,
#       year => $year,
#       disc_info => \%disc_info
#       discs => [@disc_dirs], )
#   The @discs lists contains pairs of disc name and contained files.
# Throws: Nothing
sub analyze_release {
    my ($release_path) = @_;

    # Find all the disc directories/FLAC files.
    my @rip_files = find_hierarchy($release_path);
    my @flac_files = grep {$_ =~ / \.flac \z/xms} @rip_files;
    my %disc = map {($_ ? (dirname($_) => {}) : ())} @flac_files;
    my @disc_dirs = sort keys %disc;
    my @disc_folder_names = map {basename($_)} @disc_dirs;

    # Find info about all the present discs.
    my $release_artist;
    my $release_title;
    my $release_year;
    for my $disc_dir (keys %disc) {
        #print {\*STDERR} $disc_dir, "\n";
        next if !defined $disc_dir || !-d $disc_dir;
        # Get the song files.
        my @disc_files = find_file_pattern('*.flac', $disc_dir);
        @disc_files = sort @disc_files;
        croak("No FLAC files found in $disc_dir. This is unexpected...\n")
            if (!@disc_files);

        # Help subroutine to parse track position from the filename.
        my $get_position_from_file = sub {
                my $file = basename(shift); 
                $file =~ s/(\s | -) .* \z//xms; 
                return $file; };

        my @tracks;
        my $disc_artist;
        my $disc_title;
        my $disc_year;
        # Read the tags of each song.
        for my $song (@disc_files) {
            my $info = Audio::FLAC::Header->new($song);
            my %tags = %{$info->{tags}};

            # Fetch the important tags.
            my $pos = $get_position_from_file->($song);
            my $title = $tags{TITLE} || $tags{title} || $tags{Title};
            my $artist = $tags{ARTIST} || $tags{artist} || $tags{Artist};
            my $album_artist = $tags{ALBUMARTIST} || $tags{albumartist} || $tags{Albumartist};
            my $date = $tags{date} || $tags{DATE} || $tags{Date};
            my $year;
            if ($date =~ m/(\d{4})/xms) {
                $year = $1;
            }
            else {
                print {\*STDERR}
                    "Warning: Can't find year in release\n";
            }
            my $release_title = $tags{ALBUM} || $tags{album} || $tags{Album};
            if (defined $album_artist) { 
                $disc_artist = $album_artist if (!defined $disc_artist);
                if (not $disc_artist eq $album_artist) {
                    print {\*STDERR} 
                        "Inconsistency: ",
                        "Album artist ($album_artist vs $release_artist)\n";
                }
            }

            # find the track duration.
            my $dur = $info->{trackTotalLengthSeconds};

            # Construct a 'track object'.
            my %track = (
                artist => $artist,
                (defined $album_artist ? (album_artist => $album_artist) : ()),
                release => $release_title,
                position => $pos,
                duration => $dur,
                year => $year,
                title   => $title,);
            push @tracks, \%track;
        }

        # Find an artist for the disc.
        if (!defined $disc_artist) {
            my @artists = map {$_->{artist}} @tracks;
            if (all_equal(@artists)) {
                $disc_artist = $artists[0];
            }
            else {
                $disc_artist = common_prefix(@artists);
            }
            if (!defined $disc_artist || 0 == length $disc_artist) {
                $disc_artist = "Various Artists";
            }
        }

        # Find a title for the disc.
        my @release_titles = map {$_->{release}} @tracks;
        if (all_equal(@release_titles)) {
            $disc_title = $release_titles[0];
        }
        else {
            croak("Inconsistency: "
                . "Album tag for files of "
                . basename($disc_dir) . ".");
        }

        # Find a year for the disc.
        my @years = map {$_->{year}} @tracks;
        if (!all_equal(@years)) {
            croak("Inconsistency: Years for disc "
                . basename($disc_dir) . ".");
        }
        $disc_year = $years[0];

        # Create a 'disc' object.
        my %disc_info = (
            title => $disc_title,
            artist => $disc_artist,
            year => $disc_year,
            tracks => \@tracks,);
        $disc{$disc_dir} = \%disc_info;
    }

    # Figure out the year of the whole release.
    my @disc_years = map {$_->{year}} values %disc;
    if (!all_equal(@disc_years)) {
        croak("Inconsistency: Varying disc years.")
    }
    $release_year = $disc_years[0];

    # Figure out the title for the whole release.
    my @disc_titles = map {$_->{title}} values %disc;
    if (!all_equal(@disc_titles)) {
        $release_title = common_prefix(@disc_titles);
    }
    else {
        $release_title = $disc_titles[0];
        #print {\*STDERR} "Using title $release_title.\n";
    }
    if (!defined $release_title || 0 == length $release_title) {
        croak("Couldn't find a release title common to all discs.");
    }

    # Find the artist for the whole release.
    my @disc_artists = map {$_->{artist}} values %disc;
    if (!all_equal(@disc_artists)) {
        my @non_various = grep {$_ !~ /Various(?:\sArtists)?/ixms} @disc_artists;
        if (all_equal(@non_various) && @non_various > 0) {
            $release_artist = $non_various[0];
        }
        elsif (@non_various > 0) {
            if (all_equal(@non_various)) {
                # All the discs by a single artist are by the same artist.
                # That artist is probably the release artist
                # TODO: Prompt user to make sure.
                $release_artist = $non_various[0];
            }
            else {
                # Multiple discs produced by a single artist.
                # However, not all the disc artists are the same.
                
                # Attempt to salvage
                $release_artist = common_prefix(@non_various);
                if ($release_artist == '') {
                    # TODO: Prompt user about which artists to use.
                    $release_artist = 'Various Artists';
                }
                else {
                    # If each disc is featuring other artsists, 
                    #  hopefully they got filtered.
                    # TODO: Prompt user to make sure $release_artist is good.
                }
            }
        }
        else {
            # Looks like all the discs are by various artists
            # TODO: Prompt user to make sure.
            $release_artist = "Various Artists";
        }
    }
    else {
        # In this case, all discs are by the same artist.
        $release_artist = $disc_artists[0];
    }

    my %release_info = (
        artist => $release_artist,
        title => $release_title,
        year => $release_year,
        discs => [@disc_dirs],
        disc_info => \%disc,
    );

    return \%release_info;
}

# Subroutine: find_release_in_search_results(
#   results => $results,
#   artist => $artist,
#   title => $title,
#   year => $edition_year,
#   discs => \@discs)
# Type: INTERNAL UTILITY
# Purpose: 
# Returns: 
sub find_release_in_search_results {
    shift;
    my $all_results = shift;
    my %r = @_;

    # Get all the release results, and only search those.
    my $results = $all_results->grep(sub {my $r = shift; $r->type =~ /release/i});
    my @releases =  @{$results->results};

    # Get information of necessity from rip arguments.
    my $title = $r{title};
    my $artist = $r{artist};
    $artist =~ s/\AVarious\s+Artists\z/Various/xms;

    # Iterate through the search results.
    my @misses;         # List of What::Discogs::Artist::Release objects.
    my @near_misses;    # List of What::Discogs::Artist::Release objects.
    my @near_miss_conflicts;# List of conflicts associated with @close_calls.
    my @close_calls;    # List of What::Discogs::Releaese objects.
    my @close_conflicts;# List of conflicts associated with @close_calls.
    my @hits;           # List of What::Discogs::Release objects.

    Results:
    for my $result (@releases) {
        if ($checked_release{$result->uri_identifier}){
            print $known_miss_char;
            next Results;
        }

        # Test to see if the release title is the same.
        my $release_title_string = "$artist - $title";
        my $no_copy_num = $result->title;
        $no_copy_num =~ s/\s+ [(] \d+ [)] \s - \s / - /xms;
        my $release_matches 
            = uc $release_title_string eq uc $no_copy_num
            || 0 == index $release_title_string, $no_copy_num
            || 0 == index $no_copy_num, $release_title_string;
        if ($release_matches) {
            my $sr = get_release(
                id => $result->uri_identifier,
                api => whatrc->discogs_api_key);

            my @conflicts = release_conflicts(release=>$sr, %r);

            if (@conflicts) {
                print $close_char;
                push @close_conflicts, [@conflicts];
                push @close_calls, $sr;
            }
            else {
                print $hit_char;
                push @hits, $sr;
            }
            $checked_release{$sr->query->id} = 1;
        }
        else {
            my $closeness = align("$artist - $title", $result->title);
            my $close_enough_to_check = $closeness > 0.82;
            if ($close_enough_to_check) {
                my $similar_release 
                    = get_release(
                        id => $result->uri_identifier, 
                        api => whatrc->discogs_api_key);
                my @miss_conflicts 
                    = release_conflicts(release=>$similar_release, %r);

                print $near_miss_char;
                push @near_miss_conflicts, \@miss_conflicts;
                push @near_misses, $similar_release;
            }
            else {
                print $miss_char;
                push @misses, $result;
            }
            $checked_release{$result->uri_identifier} = 1;
        }
    }

    print @releases ? " Done.\n" : "No releases to check.\n";

    my $choice;
    $choice = choose_perfect_match(@hits)                           if @hits;
    return $choice if defined $choice;
    $choice = choose_close_match(\@close_calls, \@close_conflicts)  if @close_calls;
    return $choice if defined $choice;
    $choice = choose_near_miss(\@near_misses, \@near_miss_conflicts)if @near_misses;
    return $choice if defined $choice;

    return;
}

# Subroutine: find_release_in_artist_page(
#   artist => $artist,
#   title => $title,
#   year => $edition_year,
#   discs => \@discs)
# Type: INTERNAL UTILITY
# Purpose: Perform an artist query and find a matching release.
#   Can fail if there's an inconsistency in artist naming between discogs and tags.
#   Can also fail when the proper artist has an unknown copy number.
# Returns: A What::Discogs::Release object when a matching release is found.
#   Returns a void otherwise.
sub find_release_in_artist_page {
    # The arguments act as a 'release' object.
    my @checked_releases;
    my %r = @_;
    my $artist = $r{artist};
    my $title = $r{title};
    my $artist_discog;
    eval { $artist_discog = get_artist(
            name => $artist, api => whatrc->discogs_api_key); };
    if (!defined $artist_discog) {
        print "! DEAD END.\n";
        return;
    }

    # Iterate through the artist discography.
    my @releases = @{$artist_discog->releases};
    my @misses;         # List of What::Discogs::Artist::Release objects.
    my @near_misses;    # List of What::Discogs::Artist::Release objects.
    my @near_miss_conflicts;# List of conflicts associated with @close_calls.
    my @close_calls;    # List of What::Discogs::Releaese objects.
    my @close_conflicts;# List of conflicts associated with @close_calls.
    my @hits;           # List of What::Discogs::Release objects.

    ARTISTRESULTS:
    for my $artist_release (@releases) {
        if ($checked_release{$artist_release->id}){
            print $known_miss_char;
            next ARTISTRESULTS;
        }

        # Test to see if the release title is the same.
        my $release_matches = $title eq $artist_release->title;
        if ($release_matches) {
            my $ar = get_release(
                id => $artist_release->id,
                api => whatrc->discogs_api_key);

            my @conflicts = release_conflicts(release=>$ar, %r);

            if (@conflicts) {
                print $close_char;
                push @close_conflicts, [@conflicts];
                push @close_calls, $ar;
            }
            else {
                print $hit_char;
                push @hits, $ar;
            }
            $checked_release{$ar->query->id} = 1;
        }
        else {
            my $closeness = align("$title", $artist_release->title);
            my $close_enough_to_check = $closeness > 0.82;
            if ($close_enough_to_check) {
                my $similar_release 
                    = get_release(
                        id => $artist_release->id, 
                        api => whatrc->discogs_api_key);
                my @miss_conflicts 
                    = release_conflicts(release=>$similar_release, %r);

                print $near_miss_char;
                push @near_miss_conflicts, \@miss_conflicts;
                push @near_misses, $similar_release;
            }
            else {
                print $miss_char;
                push @misses, $artist_release;
            }
            $checked_release{$artist_release->id} = 1;
        }
    }

    print @releases ? " Done.\n" : "No releases to check.\n";

    my $choice;
    $choice = choose_perfect_match(@hits)                           if @hits;
    return $choice if defined $choice;
    $choice = choose_close_match(\@close_calls, \@close_conflicts)  if @close_calls;
    return $choice if defined $choice;
    $choice = choose_near_miss(\@near_misses, \@near_miss_conflicts)if @near_misses;
    return $choice if defined $choice;

    return;
}

### INTERNAL UTILITY
# Subroutine: choose_perfect_match
# Usage: choose_perfect_match( @hits )
# Purpose: Prompt the user to choose from a list of "perfect fit" releases;
# Returns: The chosen What::Discogs::Release object.
# Throws: Nothing
sub choose_perfect_match {
    my (@hits) = @_;

    if (@hits) {
        if (scalar (@hits) == 1) {
            print "Only one matching release found,\n\n    "
                . summarize_perfect_match($hits[0]) . "\n\n";
            my $use_close_p = What::Prompt::YesNo->new(
                question => "Should this release be used to make the info file?");
            my $use_close_match = $use_close_p->prompt_user();
            if ($use_close_match =~ /\A y/xms) {
                return $hits[0];
            }
            return;
        }
        my @perfect_choices = map {summarize_perfect_match($_)} @hits;
        push @perfect_choices, 
            "None of these choices are correct. Keep searching.";
        my $pp = What::Prompt::Choose->new(
            question => "Multiple release with matching info found\n"
                . "Which release has the most accurate info?",
            choices => \@perfect_choices);
        my $choice = $pp->prompt_user();
        my $release_choice = $hits[$choice];
        return if !defined $release_choice;
        return $release_choice;
    }
    return;
}

### INTERNAL UTILITY
# Subroutine: _conflict_choose_
# Usage: _conflict_choose_( 
#   class => $relationship, # 'NEARMISS'/'CLOSEMATCH'
#   releases => \@close_calls
#   conflicts => \@conflicts )
# Purpose: 
#   Ask the user if they would like to start off with a release that was not
#   quite a "perfect match".
# Returns: Nothing
# Throws: Nothing
sub _conflict_choose_ {
    my %arg = @_;
    my $class = $arg{class};
    my $class_name = $arg{class} eq 'NEARMISS' ? 'near-miss' : 'close-match';
    my @releases = @{ $arg{releases} };
    my @conflicts = @{ $arg{conflicts} };

    if (@releases) {
        if (scalar (@releases) == 1) {
            print "A $class_name was found,\n"
                . summarize_match($releases[0], @{$conflicts[0]}) . "\n\n";
            my $use_close_p = What::Prompt::YesNo->new(
                question => "Should this release be used to make the info file?");
            my $use_close_match = $use_close_p->prompt_user();
            if ($use_close_match =~ /\A y/xms) {
                return $releases[0];
            }
            return;
        }

        my @possibilities = map {
            summarize_match(@{$_})
        } (map {[$releases[$_], @{$conflicts[$_] || []}]} 0 ... $#releases);
        push @possibilities, "No, these choices do not resemble my copy.";

        my $class_description 
            = $class eq 'NEARMISS' ? "nearly the same title"
            : "identical titles and nearly the same info.";


        my $pp = What::Prompt::Choose->new(
            question => "Several releases found with $class_description" 
                . "Do any of these releases look very similar to the rip?",
            choices => \@possibilities);
        my $choice = $pp->prompt_user();

        my $no_good_choices = $choice == scalar @possibilities;
        return if $no_good_choices;

        return $releases[$choice];
    }
    return;
}

### INTERNAL UTILITY
# Subroutine: choose_near_miss
# Usage: choose_near_miss( \@near_misses, \@conflicts )
# Purpose: 
#   Ask the user if they would like to start off with a release that was not
#   quite a match.
# Returns: Nothing
# Throws: Nothing
sub choose_near_miss {
    my ($near_misses, $conflicts_ref) = @_;
    return _conflict_choose_(
        class => 'NEARMISS', 
        releases => $near_misses,
        conflicts => $conflicts_ref);
}

### INTERNAL UTILITY
# Subroutine: choose_close_match
# Usage: choose_close_match( \@close_calls, \@conflicts )
# Purpose: 
#   Ask the user if they would like to start off with a release that was not
#   quite a "perfect match".
# Returns: Nothing
# Throws: Nothing
sub choose_close_match {
    my ($close_calls_ref, $conflicts_ref) = @_;
    return _conflict_choose_(
        class => 'CLOSEMATCH', 
        releases => $close_calls_ref,
        conflicts => $conflicts_ref);
}

# Subroutine: summarize_match($discogs_release)
# Type: INTERNAL UTILITY
# Purpose: Make a short summary of a matching release.
# Returns: Nothing
sub summarize_match {
    my ($dr, @probs) = @_;
    my $short_summ = summarize_perfect_match($dr);
    my $conflict_string 
        = join ("\n    ", 
            q{}, $short_summ, 
            (map {defined $_ ? '(' . $_ . ')' : ()} @probs));
    my $title_string 
        = join q{}, 
            $dr->artist_string, " - ", 
            $dr->title, 
            " [", $dr->date || q{}, "]";
    my $summ = join q{}, 
        $title_string, 
        $conflict_string;
    return $summ;
}


# Subroutine: summarize_perfect_match($discogs_release)
# Type: INTERNAL UTILITY
# Purpose: 
#   Make a short summary of the most important information for perfect matches.
# Returns: 
#   A string listing the labels, catnos, country, formats of a release
sub summarize_perfect_match {
    my $dr = shift;

    # Describe label and catno and neatly as possible.
    my $label_str = $dr->label_string();
    my $catno_str = $dr->catno_string();
    my $catno_cost = length $catno_str;
    my $allowance =     47;
    my $LC_format #     || THESE VALUES SHOULD BE EQUAL.
        = "   labels: %-47s catnos: %s";
    my $label_allowance = $allowance - $catno_cost;
    if ($label_allowance < length $label_str) {
        my $vis_length = $allowance - 3;
        $label_str =~ s/\A (.{$vis_length}).+ \z/$1.../xms
    }
    my $label_and_catno
        = sprintf $LC_format, $label_str, $catno_str;

    # Describe country and formats;
    my @format_descs = map {join ", ", @{$_->descriptions}} @{$dr->formats};
    my @format_strs;
    for my $i (0 ... $#format_descs) {
        my $f = $dr->formats->[$i];
        my $f_str = $f->type;
        if ($f->quantity > 1) {
            $f_str = join "x", $f->quantity, $f_str;
        }
        my $f_desc = $format_descs[$i];
        $f_str .= " $f_desc" if $f_desc =~ /./xms;
        push @format_strs, $f_str;
    }
    my $formats_str = join " : ", @format_strs;
    $formats_str = "[$formats_str]";
    my $country_and_format 
        = sprintf "countries: %-46s formats: %s", 
            ($dr->country || q{}) , ($formats_str || q{});

    my $summ = "$label_and_catno\n    $country_and_format";
    return $summ;
}

# Subroutine: release_conflicts(
#   release => $release, 
#   artist => $artist,
#   title => $title,
#   year => $edition_year,
#   discs => \@discs)
# Type: INTERNAL UTILITY
# Purpose: Check a discogs release, and given release info for consistency.
# Returns:
#   A list of conflicts between the release and the other supplied info.
sub release_conflicts {
    my %arg = @_;
    my $release = $arg{release};
    my @conflicts;

    # Match up basic information.
    push @conflicts,
        sprintf ("Release title mismatch; '%s' and '%s'", 
            $release->title, $arg{title})
        if !release_title_agrees($release, $arg{title});

    push @conflicts,
        sprintf ("Release artist mismatch; '%s' and '%s'", 
            $release->artist_string, $arg{artist})
        if !release_artist_agrees($release, $arg{artist});

    push @conflicts,
        sprintf ("Release year mismatch; '%s' & '%s'", 
            $release->date, $arg{year})
        if !release_year_agrees($release, $arg{year});

    # Attempt to match up the discs when there is justification to do so.
    push @conflicts, release_disc_problems($release, $arg{discs});
    return @conflicts;
}

# Release test template.
# Subroutine: release_xxxx_agrees($discogs_release, $release_xxxx)
# Type: INTERNAL UTILITY
# Purpose: Compare the xxxx of a discogs release to a given string.
# Returns: 
#   1 if the title of the discogs release is equal to $release_xxxx.
#   0 otherwise.
#sub release_xxxx_agrees {
#    return 0;
#}

# Subroutine: release_title_agrees($discogs_release, $release_title)
# Type: INTERNAL UTILITY
# Purpose: Compare the title of a discogs release to a given string.
# Returns: 
#   1 if the title of the discogs release is equal to $release_title.
#   0 otherwise.
sub release_title_agrees {
    my ($release, $title) = @_;
    my $t = lc $title;
    my $rt = lc $release->title;
    return 1 if ($rt eq $t);
    return 1 if (-1 != index $t, $rt);
    return 1 if (-1 != index $rt, $t);
    return 0;
}

# Subroutine: release_year_agrees($discogs_release, $release_year)
# Type: INTERNAL UTILITY
# Purpose:
#   Compare the year of a discogs release to a given string.
#   This may be difficult because year tags may represent original release
#   year, or edition release year.
# Returns: 
#   1 if the title of the discogs release is equal to $release_year.
#   0 otherwise.
sub release_year_agrees {
    my ($release, $year) = @_;
    my $date = $release->date();
    return 1;
}

# Subroutine: release_disc_problems($discogs_release, \@discs)
# Type: INTERNAL UTILITY
# Purpose: 
#   Attempt to match of the the release to an array of discs' info.
#   For now, a simple 'down-the-line' test of agreement for each disc.
# Returns: 
#   A list of conflicts between the matched discs.
#   TODO: Implement this method as a permutation search. 
#   There is not necessarily a guaranteed ordering.
sub release_disc_problems {
    my $release = shift;
    my @discs = @{shift @_};
    my @release_probs;
    my @audio_discs 
        = grep {$_->media =~ /\A CD | Vinyl\z/xms} @{$release->discs};
    return ("Number of audio discs are not the same.")
        if @audio_discs != scalar @discs;
    for my $i (0 .. $#discs) {
        my $di = $discs[$i];
        my $rel_di = $audio_discs[$i];
        push @release_probs, ( disc_track_problems($rel_di, $di->{tracks}) );
    }
    return @release_probs;
}

# Subroutine: disc_track_problems($disc, \@tracks)
# Type: INTERNAL UTILITY
# Purpose: 
#   Compare the tracks of a discogs release's disc to a given array of track info.
# Returns: 
#   A list of conflicts between the disc and the track list. 
#   For now, a problem is just a string description.
sub disc_track_problems {
    my ($disc, $tracks_ref) = @_;
    my @rel_tracks = @{$disc->tracks()};
    my @tracks = @{$tracks_ref};
    my @problems;

    # Return false if the number of tracks differ.
    if ($disc->num_tracks != @tracks) {
        my $track_total_msg = join q{},
            "Disc with different numbers of tracks; ",
            $disc->num_tracks, " and ", scalar @tracks;
        push @problems, $track_total_msg;
        return @problems;
        #TrackTotalException->throw( error => $track_total_msg );
    }

    # Iterate over corresponding tracks.
    for my $i (0 .. $#tracks) {
        my ($rel_ti, $ti) = ($rel_tracks[$i], $tracks[$i]);

        # Find the duration of the discogs track in seconds.
        my $rel_dur = $rel_ti->duration();

        next if !defined $rel_dur || $rel_dur eq q{};

        if ($rel_dur =~ m/(\d+):(\d{2})/xms) {
            $rel_dur = 60 * $1 + $2;
        }
        # Return false if discogs duration is more than the possed duration.
        if ($rel_dur > $ti->{'duration'} + 10) {
            my $track_dur_msg = join q{},
                "Track ", $ti->{'position'} , " has disagreeing length; ", 
                $rel_dur, " <= ", $ti->{'duration'} + 10;
            push @problems, $track_dur_msg;
            #TrackDurException->throw( error => $track_dur_msg );
        }
    }

    # Track names might be subtly misspelled. The logic is also more complex.
    # So they are not currently checked at all.

    # No reason can be found for the tracks to disagree.
    return @problems;
}

# Subroutine: release_artist_agrees($discogs_release, $release_artist)
# Type: INTERNAL UTILITY
# Purpose: Compare the artist of a discogs release to a given string.
# Returns: 
#   1 if the title of the discogs release is equal to $release_artist.
#   0 otherwise.
sub release_artist_agrees {
    my ($release, $artist) = @_;
    $artist =~ s/\AVarious\s+Artists\z/Various/xms;
    my @ras = @{$release->artists()};
    return 1 if ($artist eq 'Various' && scalar(@ras) > 1);
    #return 1
    #    if ($artist eq 'Various Artists' && $release->artist_string eq 'Various');
    for my $a (@ras) {
        return 0 if index ($artist, $a->name) == -1;
        $a =~ s/\AThe\s+(\S.*\S)\z/$1, The/xms;
        return 0 if index ($artist, $a->name) == -1;
    }
    return 1;
}

# Subroutine: all_equal(@strings)
# Type: INTERNAL UTILITY
# Purpose: Check if all strings in a list are equal.
# Returns: True if all the strings are the same.
sub all_equal {
    my @strings = @_;
    my $last;
    for my $str (@strings) {
        if (!defined $last) {
            $last = $str;
        }
        else {
            return if not $last eq $str;
        }
    }
    return 1;
}

# Subroutine: common_prefix(@strings)
# Type: INTERNAL UTILITY
# Purpose: Find the longest prefix string common to a list.
# Returns: 
#   Returns the longest prefix string. 
#   If no non-trivial prefix exists then an empty string is returned.
sub common_prefix {
    my @strings = @_;
    my $prefix = shift @strings || '';
    for my $s (@strings) { $prefix = common_prefix_pair($prefix, $s) }
    return $prefix;
}

# Subroutine: suffixes(@strings)
# Type: INTERNAL UTILITY
# Purpose: Remove the common prefix from all argument strings.
# Returns: A list of strings with the common prefix removed.
sub suffixes {
    my @strings = @_;
    my $prefix = common_prefix(@strings);
    my $rm_len = length $prefix;
    map {substr $_, 0, $rm_len, q()} @strings;
    return @strings;
}


# Subroutine: common_prefix_pair($s1, $s2)
# Type: INTERNAL UTILITY
# Purpose: Find the longest prefix string common to strings $s1 and $s2.
# Returns: 
#   Returns the longest prefix string. 
#   If no non-trivial prefix exists then an empty string is returned.
sub common_prefix_pair {
    my ($s1, $s2) = @_;
    my ($len1, $len2) = map {length $_} ($s1, $s2);
    my $max_len = $len1 > $len2 ? $len1 : $len2;
    my $prefix = '';
    for my $i (0 ... $max_len - 1) {
        my ($sub1, $sub2) = map {substr $_, $i, 1} ($s1, $s2);
        if ($sub1 eq $sub2) {
            $prefix .= $sub1;
        }
        else {
            last;
        }
    }
    return $prefix;
}

### INTERNAL UTILITY
# Subroutine: has_images
# Usage: has_images( $dir )
# Purpose: look for images in $dir.
# Returns: The images found.
# Throws: Nothing
sub has_images {
    my ($dir) = @_;

    my %is_img = (
        JPG => 1,
        JPEG => 1,
        PNG => 1,
        TIFF => 1,
    );
    # Grep file extensions for images.
    my @imgs = grep {$is_img{uc $_}}map {m/\.(\w+)\z/xms} find_hierarchy($dir);
    return @imgs;
}

### INTERNAL UTILITY
# Subroutine: fetch_cover_art
# Usage: fetch_cover_art( $discogs_release )
# Purpose: Fetch default artwork for a release.
# Returns: 
#   The path of the image if it was successfully downloaded,
#   an undefined value otherwise.
# Throws: Nothing
sub fetch_cover_art {
    my ( $discogs_release ) = @_;
    #my $rd = Dumper $discogs_release;
    #print {\*STDERR} $rd,"\n";
    return if has_images(whatrc->rip_dir);
    if (!$discogs_release->has_images()) {
        print "No images could be found for the discogs release.\n";
        return;
    }

    # Get the image uri, and its filetype (extension).
    my $img_uri = $discogs_release->image(0);
    if ($img_uri !~ m/\.(\w+)\z/xms) {
        die "Couldn't can't determine image extension; '$img_uri'";
    }
    my $img_ext = $1;

    # Create a path for the download.
    my $cover_name = "Cover.$img_ext";
    my $img_path = join '/', whatrc->rip_dir, $cover_name;

    # Try to download the image.
    print "Attempting to fetch image", ($opt{'--verbose'} ? ".\n" : " ... ");
    my $dl_err 
        = $subsystem->exec(
            'wget', 
            ($opt{'--verbose'} ? '--no-verbose' : '--quiet'), 
            $img_uri, '-O', $img_path);
    if ($dl_err) {
        warn "Couldn't fetch $img_path from $img_uri; ($dl_err)\n$?\n";
        return;
    }
    print "Done.\n" if !$opt{'--verbose'};

    # Return the image path.
    return $img_path;
}

# Finally, kickstart the script
main();

__END__

=head1 NAME

release-mkinfo
-- Create and nfo file for a rip, backed up by online databases.

=head1 VERSION

Version 0.0_1
Originally created on 10/10/10 17:43:36

=head1 USAGE

release-mkinfo [options]

=head1 REQUIRED ARGUMENTS

=over

=back

=head1 OPTIONS

=over

=item --skip-existing | -s

If Info.txt or a .nfo file exist already, do not try to generate them.

=item --verbose

=item --dry-run

=item --version

=item --usage

=item --help

=item --man

Print the usual program information

=back

=head1 DESCRIPTION

Search for latest rip in online databases (currently only discogs) and 
create a release description (.nfo file).

This programs need more testing, or at least more options,
before it's included in the mkrelease workflow.

For now, it's performance can't be guaranteed but, I have gotten it working 
in all the test cases I have thought to choose for their special properties.

Let me know if it fails on a particular release. I will try to remedy the 
problem as quickly as possible.

=head1 BUGS

=over

=back

=head1 AUTHOR & COPYRIGHT 

©Bryan Matsuo (bryan.matsuo@gmail.com)

