#!/usr/bin/env perl
# Use perldoc or option --man to read documentation
###################################################

our $VERSION = "00.00_01";
# Originally created: 11/22/10 22:44:02.

# Include core modules.
use strict;
use warnings;
use File::Basename;
use Carp;
use POSIX qw(ceil);

# Include CPAN modules.
use Getopt::Euclid qw{ :vars<opt_> };

# Include private modules.
use What;
use What::WhatRC;
use What::Utils;
use What::Subsystem;
use What::Format::FLAC;

########################################################################
# GENERAL GLOBAL VARIABLES
########################################################################

# Basic program information.
my $prog_incantation  = $0;
my $prog_dir          = dirname($0);
my $prog_name         = basename($0);

# Command-line option hash.
my %opt = %ARGV;

# Global program exitcode.
my $exitcode = 0;

########################################################################
# PROGRAM SPECIFIC GLOBALS
########################################################################

my $temp_img_dir = What::temp_img_dir;
if (!-d $temp_img_dir) {
    print {\*STDERR}
        "Can't find temporary image directory.\n"
        . "Please run the latest version of the 'setup' script.\n";
    exit 1;
}

my $ok_img_format 
    = qr{(?: tiff | jpg | png )}xms;

my $kilo = 2<<9;

# Image size (in KB) can be at most (<What.CD constraint> - $size_buffer).
my $size_buffer = 5;
my $max_img_size = What::embedded_art_size_limit - $size_buffer;
my $subsystem = What::Subsystem->new(
    is_dryrun   => $opt{'--dry-run'},
    verbose     => $opt{'--verbose'}, );

########################################################################
# MAIN FUNCTION
########################################################################

# main() - main program execution 
sub main{
    my @release_files = find_hierarchy(whatrc->rip_dir);
    my @tiffs = grep {$_ =~ /\. tiff \z/ixms} @release_files;
    for my $f (@tiffs) {
        print sprintf "%s\n", scale_down($f);
    }
    exit($exitcode);
}

########################################################################
# SUPPORTING SUBROUTINES
########################################################################

### INTERNAL UTILITY
# Subroutine: is_image
# Usage: is_image( $img )
# Purpose: Compute value of logical statement "$img is an image file".
# Returns: Boolean.
# Throws: Nothing
sub is_image {
    my ($img) = @_;
    die "No such image; $img." if !-e $img;
    return 1 if $img =~ m/ \. $ok_img_format \z/ixms;
    return;
}

### INTERFACE SUB
# Subroutine: scale_down
# Usage: scale_down( $img )
# Purpose: Scale an image until it fits the What.CD size constraints.
# Returns: 
#   The path to the scaled image, 
#   which must be moved or deleted 'manually' later.
# Throws: Nothing
sub scale_down {
    my ($img) = @_;
    my $init_size = size_in_KB($img);

    return $img if $init_size <= $max_img_size;

    # Make a square $square_pixels wide.
    my $scale_pixels=800;
    my $scale_delta =10;
    my $min_scale   =350;
    my $scaled = scale_img_to_size($img, $scale_pixels);
    while (size_in_KB($scaled) > $max_img_size) {
        my $scale_pixels -= $scale_delta;
        my $scaled = scale_img_to_size($img, $scale_pixels);
        if ($scale_pixels < $min_scale) {
            my $size = size_in_KB($scaled).'KB';
            my $geometry = sprintf "%dx%d", $min_scale, $min_scale;
            if ($opt{'--verbose'}) {
                print {\*STDERR} "Giving up on scaling."
                    . "Picture is smaller than $geometry."
                    . "Picture size is $size.";
            }
            return;
        }
    }

    return $scaled;
}

### INTERNAL UTILITY
# Subroutine: size_in_KB
# Usage: size_in_KB( $path )
# Purpose: 
#   Upper bound the size of $$path within 5 KB.
#   Tries to take page size into account.
# Returns: File size in kilobytes.
# Throws: Nothing
sub size_in_KB {
    my ($path) = @_;
    die "No such path; $path." if !-e $path;
    my $size_in_bytes = -s $path;
    my $size_in_kilobytes = ceil($size_in_bytes / $kilo);
    my $mod_page_size = $size_in_kilobytes % 4;
    if ($mod_page_size) {
        $size_in_kilobytes += 4 - $mod_page_size;
    }
    return $size_in_kilobytes;
}

### INTERNAL UTILITY
# Subroutine: scale_img_to_size
# Usage: scale_img_to_size( $img, $max_dim )
# Purpose: Scale $img to fix in a box of $max_dim pixels.
# Returns: Nothing
# Throws: Nothing
sub scale_img_to_size {
    my ($img, $max_dim) = @_;
    my $geometry = sprintf '%dx%d', $max_dim, $max_dim;
    my $name = basename($img);

    my $format;
    if ( $name =~ m/\. ($ok_img_format) \z /ixms) {
        $format = uc $1;
        if ($format eq 'TIFF') {
            substr $name, length ($name) - 4, 4, 'jpg';
        }
    }
    else {
        die "Can't determine format of $img.";
    }

    my $tmp_img = "$temp_img_dir/$name";

    my @img_scale = (
        'convert',
        $img,
        '-resize', $geometry,
        $tmp_img,
    );
    $subsystem->exec(@img_scale) == 0
        or die "Failed converting image $img to $tmp_img";

    return $tmp_img;
}

# Finally, kickstart the script
main();

__END__

=head1 NAME

release-embed-image
-- Safely embed the rip's cover art in FLAC files.

=head1 VERSION

Version 00.00_01

=head1 USAGE

release-embed-image [options]

=head1 REQUIRED ARGUMENTS

=over

=back

=head1 OPTIONS

=over

=item --version

=item --usage

=item --help

=item --man

Print the usual program information

=back

=head1 DESCRIPTION

release-embed-image does three things

    Find album cover art in the rip directory.

    Convert that to a size acceptable on What.CD.

    Embed the cover art into FLAC files in the rip directory.

=head1 BUGS

=over

=back

=head1 AUTHORS

Bryan Matsuo [bryan.matsuo@gmail.com] (primary author)

=head1 COPYRIGHT 

(c) Bryan Matsuo [bryan.matsuo@gmail.com]
