#!/usr/bin/env perl

# Use perldoc or option --man to read documentation

########################################################################
# MODULES
########################################################################

# Include core modules.
use strict;
use warnings;
use File::Basename;
use File::Glob qw{bsd_glob};
use Cwd qw{abs_path};
use Carp;

# Include CPAN modules.
use Getopt::Euclid qw{ :vars<opt_> };
use Readonly;
use MP3::Info;

# Include private modules.
# ...

our $VERSION = '0.0.1';

########################################################################
# GENERAL GLOBAL VARIABLES
########################################################################

# Basic program information.
Readonly my $prog_incantation  => $0;
Readonly my $prog_dir          => dirname($0);
Readonly my $prog_name         => basename($0);

# Command-line option hash.
my %opt = %ARGV;

# Global program exitcode.
my $exitcode = 0;

########################################################################
# PROGRAM SPECIFIC GLOBALS
########################################################################

########################################################################
# MAIN FUNCTION
########################################################################

# main() - main program execution 
sub main{
    my ($src_dir, $target_dir) 
        = map {abs_path($_)} 
            ($opt{'--mp3-source'}, $opt{'--target-dir'});

    my $src_base = basename($src_dir);
    my $target_base = basename($target_dir);

    $src_dir =~ s{ / \z }{}xms;

    my $image_ext = $opt{'--image-ext'};

    croak("Image file extension can not be empty") if -z $image_ext;

    # Initialize hash grouping files with similar bitrates (320, V0, ...).
    my %files_with_rate;

    # Locate all mp3 files in the source directory with a glob.
    # Must use subroutine bsd_glob( ) to avoid whitespace seperators.
    my $src_dir_glob_str = escape_glob_metachar($src_dir);
    my @src_mp3s = bsd_glob($src_dir_glob_str."/*.mp3");
    my @src_others 
        = (
            bsd_glob("$src_dir_glob_str/*.cue"),
            bsd_glob("$src_dir_glob_str/*.log"),
            bsd_glob("$src_dir_glob_str/*.$image_ext"),
        );

    # Iterate through mp3 files.
    for my $mp3_path (@src_mp3s) {

        # Determine the bitrate of the mp3.
        my $bitrate_class = classify_mp3_bitrate($mp3_path);

        # Add the mp3 to the propper bitrate class.
        my $class_ref = $files_with_rate{$bitrate_class};
        if (defined $class_ref){ push @{$class_ref}, $mp3_path; }
        else { $files_with_rate{$bitrate_class} = [$mp3_path]; }
    }

    my @found_classes = keys %files_with_rate;

    for my $bitrate_class (@found_classes) {
        # Construct a folder for the bitrate class.
        my $class_dir = "$target_dir/$target_base [$bitrate_class]";

        # Ensure class directory exists.
        make_dir($class_dir);

        # Copy cue, log, and image files to the new class directory.
        my @cp_other_cmd = ('cp', @src_others, $class_dir);
        system(@cp_other_cmd) == 0
            or croak("Couldn't copy files to $class_dir;"
                .join(":", @src_others));

        my $class_copy_num 
            = copy_number(@{$files_with_rate{$bitrate_class}})

        # Iterate over mp3s with the same class.
        for my $mp3_path (@{$files_with_rate{$bitrate_class}}) {

            # Extract the filename from the path.
            my $mp3_name = basename($mp3_path);

            $mp3_name =~ s/-$class_copy_num\.mp3\z/.mp3/xms
                if $class_copy_number;

            # Construct a destination path for the mp3.
            my $mp3_dest = "$class_dir/$mp3_name";

            my @mv_mp3_cmd = ('mv', $mp3_path, $mp3_dest);

            system(@mv_mp3_cmd) == 0
                or croak("Couldn't move $mp3_path to $mp3_dest");
        }
    }

    exit($exitcode);
}

########################################################################
# SUPPORTING SUBROUTINES
########################################################################

# Subroutine: copy_number(@mp3_files)
# Type: INTERFACE SUB
# Purpose: 
#   Determine if a copy number is shared between a set of files.
# Returns: 
#   The copy number if one is found. Zero otherwise.
sub copy_number {
    my @mp3s = @_;

    return 0 if @mp3s == 0;

    my $first = $mp3s[0];

    return 0
        if ($first =~ m/-(\d+)\.mp3\z/xms);

    my $possible_copy_number = $1;

    for my $mp3 (@mp3s) {
        return 0 if $mp3 !~ m/-$possible_copy_number\.mp3/xms;
    }

    return 1;
}

# Subroutine: make_dir($dir_name)
# Type: INTERFACE SUB
# Purpose: 
#   Create a new directory.
# Returns: undef
# Raises: 
#   Croaks if $dir_name is not a directory, or if it can't be created.
sub make_dir {
    my $dir_name = shift;

    if (-e $dir_name) {
        croak("$dir_name already exists.");
    }
    else {
        # Attempt to create the directory.
        system("mkdir", $dir_name) == 0
            or croak("Can not create directory $dir_name;\n$?\n");
    }
    return;
}

# Subroutine: escape_glob_metachar($glob_str)
# Type: INTERFACE SUB
# Purpose: 
#   Escape all of glob's metacharacters \,[,],{,},*,?,~
# Returns: 
#   A copy of $glob_str with metacharacters escaped
sub escape_glob_metachar {
    my $glob_str = shift;
    $glob_str =~ s!(\\|\[|\]|[{}*?~])!\\$1!gxms;
    return $glob_str;
}

# Subroutine: classify_mp3_bitrate($filename)
# Type: INTERFACE SUB
# Purpose: 
#   Classify the bit-rate of given mp3 file.
# Returns: 
#   The bit-rate of the file ('V0', 'V2', '320', '192', ...)
#   Croaks when the given file is not an mp3, or when VBR quality setting
#   is not 0 or 2.
#   TODO: Throw various exception types (not mp3, bad VBR setting, ...)
sub classify_mp3_bitrate {
    my $filename = shift;

    my $info = get_mp3info($filename);

    croak($@) if (!defined $info);

    my $bitrate = $info->{BITRATE};
    my $is_vbr = $info->{VBR};

    if ($is_vbr) { # The mp3 uses a variable bitrate.
        my $vbr_scale = $info->{VBR_SCALE};

        # Currently, only V0 and V2 are supported as VBR bitrates.
        # Non-zero quality files have not been tested yet.
        my $lame_scale = 10 + $opt{'-q'} - $vbr_scale / 10;

        $lame_scale
            = $lame_scale =~ m/\A 0 (?: [.]0+ )? \z/xms ? 0
            : $lame_scale =~ m/\A 2 (?: [.]0+ )? \z/xms ? 2
            : undef;

        croak("VBR scale of $filename is neither 80 nor 100. $vbr_scale") 
            if !defined $lame_scale;

        return "V$lame_scale";
    }
    else { # The mp3 uses a constant bit rate.
        return $bitrate;
    }

    return;
}


# Finally, kickstart the script
main();

__END__

=head1 NAME

segregate-mp3
-- short description

=head1 VERSION

Version 0.0_1
Originally created on 07/07/10 16:00:45

=head1 USAGE

segregate-mp3 [options]

=head1 REQUIRED ARGUMENTS

=over

=back

=head1 OPTIONS

=over

=item -s <srcdir> | --mp3-source [=] <srcdir>

A directory with mp3 files. Files with different bitrates will be
seperated into different folders.

The default value for <srcdir> is '.'

=for Euclid:
    srcdir.type: readable, -d srcdir
    srcdir.default: '.'

=item -t <targetdir> | --target-dir

Folders will be made in <targetdir>, one for each bit rate found in
<srcdir>.

As an example, let <srcdir> be '/some/path/to/mp3s'. In the
<srcdir> directory, imagine there are 320kbps and VBR V0 music files.
The directories produced will be '<target-dir>/mp3s [320]/' and
'<target-dir>/mp3s [V0]/'. Note that the basename of <srcdir> is used
as the prefix in the folder name.

The default value for <targetdir> is '.'

=for Euclid:
    targetdir.type: writable, -d targetdir
    targetdir.default: '.'

=item -q <quality> | --quality [=] <quality>

Value of the -q option used to encode the mp3. q0 is assumed as the
default.

=for Euclid:
    quality.type: 0+integer
    quality.default: 0

=item -i <imgext> | --image-ext [=] <imgext>

File extension for included images. Default: 'tiff'

=for Euclid:
    imgext.default: 'tiff'

=item --version

=item --usage

=item --help

=item --man

Print the usual program information

=back

=head1 DESCRIPTION

=head1 BUGS

=over

=back

=head1 AUTHOR & COPYRIGHT 

Â©Bryan Matsuo (bryan.matsuo@gmail.com)

