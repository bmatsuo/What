#!/usr/bin/env perl

# Use perldoc or option --man to read documentation

########################################################################
# MODULES
########################################################################

# Include core modules.
use strict;
use warnings;
use File::Basename;
use File::Glob qw{bsd_glob};
use List::Util qw{first};
use Carp;
my $USER_HAS_THREADS;
if (eval {use threads; 1}) {
    $USER_HAS_THREADS = 1 
}
else{
    eval {use What::ThreadDummy;}
}
use Thread::Queue;

# Include CPAN modules.
use Getopt::Euclid qw{ :vars<opt_> };
use Audio::FLAC::Header;
use Readonly;
use MP3::Tag;

use Exception::Class (
    'PrerequisiteError', 
    'BitrateError',
    'SystemCallError' => {alias=>'syserr'},);

# Include private modules.
use What::Utils;
use What::WhatRC;
use What::Release;
use What::Format;
use What::Subsystem;
use What::Context;
use What::Format::FLAC;
use What::Converter::WAVE;
use What::Converter::MP3;
use What::Converter::AAC;
use What::Converter::Ogg;

########################################################################
# GENERAL GLOBAL VARIABLES
########################################################################

# Basic program information.
Readonly my $prog_incantation  => $0;
Readonly my $prog_dir          => dirname($0);
Readonly my $prog_name         => basename($0);

# Command-line option hash.
my %opt = %ARGV;

# Global program exitcode.
my $exitcode = 0;

########################################################################
# PROGRAM SPECIFIC GLOBALS
########################################################################

#my $wav_c = What::Converter::WAVE->new(verbose => $opt{'--verbose'});
#my $mp3_320_c = What::Converter::MP3->new(bitrate => '320', verbose => $opt{'--verbose'});
#my $mp3_v0_c = What::Converter::MP3->new(bitrate => 'v0', verbose => $opt{'--verbose'});
#my $mp3_v2_c = What::Converter::MP3->new(bitrate => 'v2', verbose => $opt{'--verbose'});
#my $ogg_c = What::Converter::Ogg->new(verbose => $opt{'--verbose'});
#my $aac_c = What::Converter::AAC->new(verbose => $opt{'--verbose'});
my $subsystem = What::Subsystem->new(
    verbose => $opt{'--verbose'},
    dry_run => $opt{'--dry-run'},);

########################################################################
# MAIN FUNCTION
########################################################################

# main() - main program execution 
sub main{
    load_context();
    local $| = 1;
    my $artist = context->artist;
    my $title = context->title;
    my $year = context->year;

    my %release_info
        = (artist => $artist, title => $title, year => $year);

    my $release = What::Release->new( %release_info );
    my @existing_formats = $release->existing_formats();

    my @mp3_opts = map {uc $_} @{$opt{'--mp3'}};
    my @allowed_format_opts = map {$opt{"--$_"} ? $_ : () } (formats());
    my @format_opts = (@allowed_format_opts, @mp3_opts);
    my @desired_formats;
    for my $f (@format_opts) {
        my $format_exists = $release->exists($f);
        if ($format_exists) {
            my $fnorm = format_normalized($f);
            print {\*STDERR} 
                "Warning: $fnorm release already exists."
                . " Not transcoding to $fnorm.\n";
        }
        else {
            push @desired_formats, $f;
        }
    }

    if (!@desired_formats) {
        print {\*STDERR} "No formats to create. Exiting.\n";
        exit 0;
    }

    my %format_needs_wav = (
        v0 => 1,
        v2 => 1,
        320 => 1,
        aac => 1,
        ogg => 0,);
    my $should_create_wav
        = scalar 
            (map {format_needs_wav($_) ? ($_) : ()} @desired_formats);


    my %converted_to;
    for my $format (@desired_formats) { $converted_to{$format} = {} }
    my %dest_for;

    my $upload_root = whatrc->upload_root;
    my $subsystem = What::Subsystem->new();

    my $release_root_name = $release->name();

    my $release_path = $release->dir();

    PrerequisiteError->throw(
        error=>"Release root does not exist; $release_path")
            if (!-d $release_path or !-w $release_path);
    
    $release_path =~ s/\A ~/$ENV{'HOME'}/xms;

    my @flac_dirs 
        = $release->format_disc_dirs('FLAC');

    my $release_is_multidisc = @flac_dirs > 1 ? 1 : 0;

    my $flac_source_dir = $release->format_dir('flac');

    #my %flac_info = flac_files_in($flac_source_dir);
    #my %flac_info 
    #    = grep {$_ =~ m/ \. flac \z/xms} find_hierarchy($flac_source_dir);
    #= (map {flac_files_in($_)} @flac_dirs);
    my @flac_files 
        = grep {$_ =~ m/ \. flac \z/xms} find_hierarchy($flac_source_dir);

    for my $format (@desired_formats) {
        print "Finding $format directories..." if $opt{'--verbose'};
        my $format_dest_dir 
            = $release->format_dir($format);
        if (!-d $format_dest_dir) {
            $subsystem->exec('mkdir', $format_dest_dir) == 0
                or syserr(
                    error=>
                        "Couldn't create directory $format_dest_dir\n$?");
        }

        print "Found\n" if $opt{'--verbose'};

        $dest_for{$format} = $format_dest_dir;

        # Create multiple disc directories if necessary.
        if ($release_is_multidisc) {
            print "\nFinding disc directories for $format...";

            for my $disc_dir (@flac_dirs) {
                my $disc_name = basename($disc_dir);
                my $format_disc_dir = "$format_dest_dir/$disc_name";
                if (!-d $format_disc_dir) {
                    $subsystem->exec('mkdir', $format_disc_dir) == 0
                        or syserr(
                            error=> "Couldn't create disc directory"
                                ."$format_disc_dir\n$?");
                 }
            }

            print "DONE\n";
        }
    }

    my $conv_q = Thread::Queue->new();
    my $num_conv = 0;
    my %dependent_convs;
    my %num_dependent;

    print sprintf ("%14s", "Preparing jobs"), ($opt{'--verbose'} ? '...' : q{});
    my $converter_id = 0;
    # Convert each flac file into all desired formats.
    for my $flac_path (
        sort 
            {
                do {basename($a) =~ m/\A (\d+)/xms ? $1 : 0} 
                    <=> do {basename($b) =~ m/\A (\d+)/xms ? $1 : 0} }
            @flac_files
    ) {
        my $flac_obj = read_flac($flac_path);

        my $temp_wav_dest_dir = safe_path('~/.what/work/wav'); #dirname($flac_path);

        my $wav_path;

        # Create temporary file for WAVE output.
        # my $wav_path = wav_output($flac_path, $temp_wav_dest_dir);

        # Create a name for reencoded MP3 files.
        my $flac = basename($flac_path);

        if ($opt{'--verbose'}) {
            print sprintf (
                "[ %02d %s:", 
                (map {$flac_obj->tag($_)} qw{TRACKNUMBER TITLE}));
        }

        if ($should_create_wav) {
            my $new_wav_c = What::Converter::WAVE->new(
                flac => $flac_obj,
                dest_dir => $temp_wav_dest_dir,
                append_id => 1,
                id => $converter_id++,
            );
            if ($opt{'--verbose'}) {
                print q{ }.$new_wav_c->format_descriptor;
            }
            else {
                print '.';
            }
            $conv_q->enqueue([$new_wav_c,]);
            ++$num_conv;
            #$wav_c->flac($flac_obj);
            #$wav_c->dest_dir($temp_wav_dest_dir);
            #$wav_c->convert();
            $wav_path = $new_wav_c->output_path;
            $dependent_convs{$wav_path} = [];
            $num_dependent{$wav_path} = 0;
            
        }

        # Convert the decoded WAVE into all desired formats.
        for my $format (@desired_formats) {
            my $uc_format = uc $format;

            my $disc_subdir 
                = $release_is_multidisc 
                    ? "/".basename(dirname($flac_path)) : "";
            my $dest_dir = $dest_for{$format};
            $dest_dir .= $disc_subdir;
            my $file_format = file_format_of($uc_format);

            # Select the converter to use.
            my $conv 
                = $file_format eq 'MP3'   ? What::Converter::MP3->new (
                                            bitrate => $uc_format,
                                            id => $converter_id++, )
                : $file_format eq 'OGG'   ? What::Converter::Ogg->new (
                                            id => $converter_id++, )
                : $file_format eq 'AAC'   ? What::Converter::AAC->new (
                                            id => $converter_id++,)
                : undef;

            if (!defined $conv) {
                croak("Didn't recognize format $uc_format.");
            }

            if ($opt{'--verbose'}) {
                print q{ }.$conv->format_descriptor;
            }
            else {
                print '.';
            }

            # Create the transcode.
            ++$num_conv;
            $conv->flac($flac_obj);
            $conv->dest_dir($dest_dir);
            if ($conv->needs_wav()) {
                push @{$dependent_convs{$wav_path}}, $conv;
                ++$num_dependent{$wav_path};
            }
            else {
                $conv_q->enqueue([$conv,]);
            }
        }

        print ' ]' if $opt{'--verbose'};

        if ($should_create_wav) { # Then we should destroy the wav.

        }
    }
    print "Done\n";
    print sprintf ("%14s", "Converting"), ($opt{'--verbose'} ? '...' : q{});

    my $num_threads = 0;
    my $thread_action = sub {
        ++$num_threads;
        threads->exit() if $USER_HAS_THREADS && !$conv_q->pending();
        my $conv_job = $conv_q->dequeue();
        my ($c, $wav) = @{$conv_job};
        my %arg;
        $arg{wav} = $wav if defined $wav;
        my $c_res = eval { $c->convert(%arg) };
        if ($@) {
            print {\*STDERR} "Error converting: $@\n";
            return "FAIL";
        }
        my $out = $c->output_path;

        if (!$opt{'--verbose'}) {
            print '.';
        }
        elsif ($c->flac->tag('discnumber')) {
            print sprintf (
                "[ [%s] %02d-%02d ]",
                $c->format_descriptor,
                $c->flac->tag('discnumber'),
                $c->flac->tag('tracknumber') 
            );
        }
        else {
            print sprintf (
                "[ [%s] %02d ]",
                $c->format_descriptor,
                $c->flac->tag('tracknumber')
            );
        }


        my $now_ok = $dependent_convs{$out};
        if (defined $now_ok) {
            my @new_convs = map {[$_, $out]} @{$now_ok};
            if (@new_convs) {
                $conv_q->insert(1, @new_convs);
            }
        }

        return [$c, $wav];
    };

    my $max_threads = whatrc->max_threads;
    my $thread_error = 0;

    my $thread_completion_action = sub {
        return if $thread_error;
        if (!defined $_[0] || $_[0] eq 'FAIL') {
            print {\*STDERR} 
                "Error detected in conversion thread."
                . " Clearing conversion queue, finishing active jobs,"
                . " and halting.\n";
            $conv_q->extract(0, $num_conv);
            $thread_error = 1;
            return;
        }
        my ($converter, $used_wav) = @{$_[0]};
        if (defined $used_wav) {
            --$num_dependent{$used_wav} if $num_dependent{$used_wav};
            if ($num_dependent{$used_wav} == 0) {
                # Remove the WAVE path.
                if (!$opt{verbose}) {
                    # Print nothing.
                }
                elsif ($converter->flac->tag('discnumber')) {
                    print sprintf (
                        "! RM [WAVE] %02d-%02d !",
                        $converter->flac->tag('discnumber'),
                        $converter->flac->tag('tracknumber') 
                    );
                }
                else {
                    print sprintf (
                        "! RM [WAVE] %02d !",
                        $converter->flac->tag('tracknumber')
                    );
                }
                $subsystem->exec('rm', $used_wav) == 0
                    or syserr( error => join "\n", 
                                        "Couldn't remove temporary file;",
                                        , basename($used_wav) , $?);
                ;
            }
        }
    };

    while ( $conv_q->pending() 
            || ($USER_HAS_THREADS && threads->list(threads::running) > 0)
            || ($USER_HAS_THREADS && threads->list(threads::joinable) > 0)) {
        if (!$USER_HAS_THREADS) {
            $thread_completion_action->($thread_action->());
            next;
        }
        my $thread_buffer_size = scalar threads->list(threads::running);
        if ( $conv_q->pending() && $thread_buffer_size < $max_threads ) {
            for (0 .. $max_threads - $thread_buffer_size) {
                my $thready = threads->create($thread_action);
            }
        }
        else {
            sleep 1;
        }
        for my $fin_thread (threads->list(threads::joinable)) {
            my $ressy = $fin_thread->join();
            $thread_completion_action->($ressy) if defined $ressy;
        }
    }

    my @remaining_wavs = find_file_pattern('*.wav', '~/.what/work/wav');
    if (@remaining_wavs) {
        if ($opt{'--verbose'}) {
            print map {sprintf ("! RM [WAVE] %s !", $_)} @remaining_wavs;
        }
        $subsystem->exec('rm', @remaining_wavs) == 0
            or syserr( error => "Couldn't remove temporary files;\n"
                                . "@remaining_wavs\n$?");
    }

    print "Done\n";

    # Remove partial releases and quit if a converter thread crashed.
    if ($thread_error) {
        my @rm_partials = 
            ('release-delete', 
                map {
                    file_format_of($_) eq 'MP3' ? "--mp3 $_" : "--$_"
                } @desired_formats );
        print {\*STDERR} "Removing partially transcoded releases.\n";
        $subsystem->exec(@rm_partials) == 0
            or croak("Couldn't remove partially transcoded releases"
                . "@desired_formats.\n");
        exit 1;
    }

    print "Copying accompanying files..." if $opt{'--verbose'};

    # This just makes the files in the root directory get copied.
    push @flac_dirs, $flac_source_dir 
        if !(grep {$_ eq $flac_source_dir} @flac_dirs);

    # Copy other files in each disc directory, and reformat m3u.
    for my $disc_dir (@flac_dirs) {
        # Find the non-audio files in the disc directory.
        my @other_disc_files = find_file_pattern("*", $disc_dir);
        @other_disc_files = grep {$_ !~ m/\A \./xms} @other_disc_files;
        @other_disc_files 
            = grep {$_ !~ m/\.(flac | cue | log)\z/xms} @other_disc_files;

        # Find an M3U for the disc, and remove for special treatment.
        my @flac_m3us = grep {$_ =~ m/\.m3u\z/xms} @other_disc_files;
        my $flac_m3u = shift @flac_m3us;
        if (@flac_m3us > 0) {
            print {\*STDERR} 
                "wtf?! multiple M3Us found; $flac_m3u and @flac_m3us\n";
            print {\*STDERR} "skipping @flac_m3us\n";
        }
        if (!defined $flac_m3u) {
            die "No m3u found in FLAC disc directory; $disc_dir\n";
        }
        @other_disc_files = grep {$_ !~ m/\.m3u\z/xms} @other_disc_files;

        # Copy the files to each of the created format directories.
        my $disc_name = basename($disc_dir);
        for my $format (@desired_formats) {
            my $format_ext = format_extension($format);
            my $format_dir = $release->format_dir($format);
            my $flac_root = $release->format_dir('flac');
            my $flac_root_name = basename($flac_root);

            # Name the disc directory for the given format.
            my $format_disc_dir 
                = $disc_name eq $flac_root_name ? $format_dir 
                : "$format_dir/$disc_name";

            # Attempt to copy the non-flac, non-playlist files.
            if (@other_disc_files > 0) {
                my @cp_other_disc_files 
                    = ('cp', '-r',  @other_disc_files, $format_disc_dir);
                if ($subsystem->exec(@cp_other_disc_files) != 0) {
                    my @files = map {basename($_)} @other_disc_files;
                    my @err 
                        = ("Couldn't copy files to $format_disc_dir", 
                            @files);
                    syserr( error => join ("\n", @err, ""), );
                }
            }

            # Write a reformated M3U to the disc directory as well.
            open my $m3u_in, "<", $flac_m3u
                or die "Couldn't open playlist $flac_m3u.";
            my $m3u = do {local $/; <$m3u_in>};
            close $m3u_in;
            $m3u =~ s/\.flac ( \n | \z )/\.$format_ext$1/gxms;
            my $format_m3u = "$format_disc_dir/".basename($flac_m3u);
            open my $m3u_out, ">", $format_m3u
                or die "Can't write to playlist $format_m3u.";
            print {$m3u_out} $m3u;
            close $m3u_out;
        }
    }

    print "Done\n" if $opt{'--verbose'};

    exit($exitcode);
}

########################################################################
# SUPPORTING SUBROUTINES
########################################################################

# Subroutine: wav_output($flac_file, $wav_dest_dir)
# Type: INTERFACE SUB
# Purpose: 
#   Compute the decoded output file for a given FLAC file.
# Returns: 
#   Path to the decoded WAVE file.
sub wav_output {
    my ($flac, $wav_dir) = @_;
    my $wav_name = basename($flac);
    $wav_name =~ s/ \.flac \z/.wav/xms;
    my $wav_path = "$wav_dir/$wav_name";
    return $wav_path;
}

# Finally, kickstart the script
main();

__END__

=head1 NAME

convert-flac-release
-- Convert a FLAC release to a number of other formats.

=head1 VERSION

Version 0.0_1
Originally created on 07/15/10 01:42:25

=head1 USAGE

convert-flac-release [options]

=head1 REQUIRED ARGUMENTS

=over

=item --artist <artist>

Release artist.

=for Euclid:
    artist.type: string, length artist

=item --title <title>

=for Euclid:
    title.type: string, length title

Release title.

=item --year <year>

Release year.

=for Euclid:
    year.type: /\d{4}/

=back

=head1 OPTIONS

=over

=item --v0 | --V0

Convert FLAC release to an MP3 V0 VBR release.

=item --v2 | --V2

Convert FLAC release to an MP3 V2 VBR release.

=item --320

Convert FLAC release to an MP3 320kbps CBR release.

=item --ogg | --OGG | --q8

Convert FLAC release to an OGG -q8.0 VBR release.

=item --aac | --AAC

Convert FLAC release to an AAC ~256kbps ABR release.

=item --all

Produce releases in all What.CD allowed formats and bitrates (not recommended).

=item --mp3 <quality> | --MP3 <quality>

Specify creation of CBR bitrate or VBR quality release. 
<quality> can be any of the following:

    32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320

or 

    V1, V2, V3, V4, V5, V6, V7, V8, V9

=for Euclid:
    repeatable
    quality.type: string, quality =~ m/[vV][0-9]|32|40|48|56|64|80|96|112|128|160|192|224|256|320/

=item --force-flac | -f

Force flac to overwrite any existing WAVE files.

=item --dry-run

Do not actually run any programs. Just print out commands.

=item --verbose

Print out commands prior to execution.

=item --version

=item --usage

=item --help

=item --man

Print the usual program information

=back

=head1 DESCRIPTION

Convert the FLAC release directory to a release directory of another format. 

=head1 BUGS

=over

Known to not properly transfer foreign language characters in song tags.

=back

=head1 COPYRIGHT & LICENSE

© The What team.

This file is part of What.

What is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

What is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with What.  If not, see <http://www.gnu.org/licenses/>.

=cut

