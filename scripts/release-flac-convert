#!/usr/bin/env perl

# Use perldoc or option --man to read documentation

########################################################################
# MODULES
########################################################################

# Include core modules.
use strict;
use warnings;
use File::Basename;
use File::Glob qw{bsd_glob};
use List::Util qw{first};
use Carp;
my $USER_HAS_THREADS;
if (eval {use threads; 1}) {
    $USER_HAS_THREADS = 1 
}
else{
    eval {use What::ThreadDummy;}
}
use Thread::Queue;

# Include CPAN modules.
use Getopt::Euclid qw{ :vars<opt_> };
use Audio::FLAC::Header;
use MP3::Tag;

use Exception::Class (
    'PrerequisiteError', 
    'BitrateError',
    'SystemCallError' => {alias=>'syserr'},);

# Include private modules.
use What;
use What::Utils qw{:all};
use What::WhatRC;
use What::Release;
use What::Format;
use What::Subsystem;
use What::Context;
use What::Format::FLAC;
use What::Converter::WAVE;
use What::Converter::MP3;
use What::Converter::AAC;
use What::Converter::Ogg;

########################################################################
# GENERAL GLOBAL VARIABLES
########################################################################

# Basic program information.
my $prog_incantation  = $0;
my $prog_dir          = dirname($0);
my $prog_name         = basename($0);

# Command-line option hash.
my %opt = %ARGV;

# Global program exitcode.
my $exitcode = 0;

########################################################################
# PROGRAM SPECIFIC GLOBALS
########################################################################

#my $wav_c = What::Converter::WAVE->new(verbose => $opt{'--verbose'});
#my $mp3_320_c = What::Converter::MP3->new(bitrate => '320', verbose => $opt{'--verbose'});
#my $mp3_v0_c = What::Converter::MP3->new(bitrate => 'v0', verbose => $opt{'--verbose'});
#my $mp3_v2_c = What::Converter::MP3->new(bitrate => 'v2', verbose => $opt{'--verbose'});
#my $ogg_c = What::Converter::Ogg->new(verbose => $opt{'--verbose'});
#my $aac_c = What::Converter::AAC->new(verbose => $opt{'--verbose'});
my $subsystem = What::Subsystem->new(
    verbose => $opt{'--verbose'},
    dry_run => $opt{'--dry-run'},);
my $upload_root = whatrc->upload_root;

########################################################################
# MAIN FUNCTION
########################################################################

# main() - main program execution 
sub main{
    load_context();
    local $| = 1;
    my $artist = context->artist;
    my $title = context->title;
    my $year = context->year;

    my $release = release();
    my $directory = eval { $release->directory('FLAC') };
    my $e;
    if ($e = Exception::Class->caught('IOError')) {
        die "Can't open the FLAC directory; $e->error\n";
    }

    my @desired_formats
        = grep {not $_ eq format_normalized('flac')} (arg_formats(%opt));
    if (!@desired_formats) {
        print {\*STDERR} "No formats to create. Exiting.\n";
        exit 0;
    }
    for my $f (@desired_formats) {
        if ($release->exists($f)) {
            print {\*STDERR}
                "Warning: Format $f release already exists."
                . " Not transcoding to $f.\n";
        }
    }

    my $should_create_wav = scalar grep {format_needs_wav($_)} @desired_formats;
    my $release_root_name = $release->name();
    my $release_path = $directory->path();
    my @flac_dirs = $release->format_disc_dirs('FLAC');
    my @flac_music_dirs = $directory->discs();
    my $release_is_multidisc = $#flac_music_dirs;
    my $flac_source_dir = $directory->path;
    my @flac_files = $directory->audio_files();
    #    = grep {$_ =~ m/ \. flac \z/xms} find_hierarchy($flac_source_dir);

    # Create directories for new format releases.
    my %dest_for;
    for my $format (@desired_formats) {
        print "Creating $format directory..." if $opt{'--verbose'};
        my $format_dest_dir = $release->format_dir($format);
        if (!-d $format_dest_dir) {
            $subsystem->exec('mkdir', $format_dest_dir) == 0
                or syserr(error=> "Couldn't create directory $format_dest_dir");
        }
        print "Done\n" if $opt{'--verbose'};

        $dest_for{$format} = $format_dest_dir;

        # Create multiple disc directories if necessary.
        if ($release_is_multidisc) {
            print "\nCreating disc directories for $format..." if $opt{'--verbose'};
            for my $flac_d (@flac_dirs) {
                my $dest_d 
                    = reroot($directory->path(), $format_dest_dir, $flac_d);
                if (!-d $dest_d) {
                    $subsystem->exec('mkdir', $dest_d) == 0
                        or syserr(
                            error => "Couldn't create disc directory $dest_d");
                 }
            }
            print "Done\n" if $opt{'--verbose'};
        }
    }

    my $conv_q = Thread::Queue->new();
    my $num_conv = 0;
    my %dependent_convs;
    my %num_dependent;

    print sprintf ("%14s", "Preparing jobs"), ($opt{'--verbose'} ? '...' : q{});
    my $converter_id = 0;
    my $temp_wav_dest_dir = What::temp_wav_dir();
    # Convert each flac file into all desired formats.
    for my $flac_path (
        sort 
            {
                do {basename($a) =~ m/\A (\d+)/xms ? $1 : 0} 
                    <=> do {basename($b) =~ m/\A (\d+)/xms ? $1 : 0} }
            @flac_files
    ) {
        my $flac_obj = read_flac($flac_path);

        my $wav_path;

        # Create a name for reencoded MP3 files.
        my $flac = basename($flac_path);

        if ($opt{'--verbose'}) {
            printf "[ %02d %s:", 
                (map {$flac_obj->tag($_)} qw{TRACKNUMBER TITLE});
        }

        if ($should_create_wav) {
            my $new_wav_c = What::Converter::WAVE->new(
                flac => $flac_obj,
                dest_dir => $temp_wav_dest_dir,
                append_id => 1,
                id => $converter_id++,
            );
            if ($opt{'--verbose'}) {
                print q{ }.$new_wav_c->format_descriptor;
            }
            else {
                print '.';
            }
            $conv_q->enqueue([$new_wav_c,]);
            ++$num_conv;
            $wav_path = $new_wav_c->output_path;
            $dependent_convs{$wav_path} = [];
            $num_dependent{$wav_path} = 0;
            
        }

        # Convert the decoded WAVE into all desired formats.
        for my $format (@desired_formats) {
            my $uc_format = uc $format;

            my $disc_subdir 
                = $release_is_multidisc 
                    ? "/".basename(dirname($flac_path)) : "";
            my $dest_dir = $dest_for{$format};
            $dest_dir .= $disc_subdir;
            my $file_format = file_format_of($uc_format);

            # Select the converter to use.
            my $conv 
                = $file_format eq 'MP3'   ? What::Converter::MP3->new (
                                            bitrate => $uc_format,
                                            id => $converter_id++, )
                : $file_format eq 'OGG'   ? What::Converter::Ogg->new (
                                            id => $converter_id++, )
                : $file_format eq 'AAC'   ? What::Converter::AAC->new (
                                            id => $converter_id++,)
                : undef;

            if (!defined $conv) {
                croak("Didn't recognize format $uc_format.");
            }

            if ($opt{'--verbose'}) {
                print q{ }.$conv->format_descriptor;
            }
            else {
                print '.';
            }

            # Create the transcode.
            ++$num_conv;
            $conv->flac($flac_obj);
            $conv->dest_dir($dest_dir);
            if ($conv->needs_wav()) {
                push @{$dependent_convs{$wav_path}}, $conv;
                ++$num_dependent{$wav_path};
            }
            else {
                $conv_q->enqueue([$conv,]);
            }
        }

        print ' ]' if $opt{'--verbose'};

        if ($should_create_wav) { # Then we should destroy the wav.

        }
    }
    print "Done\n";
    print sprintf ("%14s", "Converting"), ($opt{'--verbose'} ? '...' : q{});

    my $num_threads = 0;
    my $thread_action = sub {
        ++$num_threads;
        threads->exit() if $USER_HAS_THREADS && !$conv_q->pending();
        my $conv_job = $conv_q->dequeue();
        my ($c, $wav) = @{$conv_job};
        my %arg;
        $arg{wav} = $wav if defined $wav;
        my $c_res = eval { $c->convert(%arg) };
        if ($@) {
            print {\*STDERR} "Error converting: $@\n";
            return "FAIL";
        }
        my $out = $c->output_path;

        if (!$opt{'--verbose'}) {
            print '.';
        }
        elsif ($c->flac->tag('discnumber')) {
            print sprintf (
                "[ [%s] %02d-%02d ]",
                $c->format_descriptor,
                $c->flac->tag('discnumber'),
                $c->flac->tag('tracknumber') 
            );
        }
        else {
            print sprintf (
                "[ [%s] %02d ]",
                $c->format_descriptor,
                $c->flac->tag('tracknumber')
            );
        }


        my $now_ok = $dependent_convs{$out};
        if (defined $now_ok) {
            my @new_convs = map {[$_, $out]} @{$now_ok};
            if (@new_convs) {
                $conv_q->insert(1, @new_convs);
            }
        }

        return [$c, $wav];
    };

    my $max_threads = whatrc->max_threads;
    my $thread_error = 0;

    my $thread_completion_action = sub {
        return if $thread_error;
        if (!defined $_[0] || $_[0] eq 'FAIL') {
            print {\*STDERR} 
                "Error detected in conversion thread."
                . " Clearing conversion queue, finishing active jobs,"
                . " and halting.\n";
            $conv_q->extract(0, $num_conv);
            $thread_error = 1;
            return;
        }
        my ($converter, $used_wav) = @{$_[0]};
        if (defined $used_wav) {
            --$num_dependent{$used_wav} if $num_dependent{$used_wav};
            if ($num_dependent{$used_wav} == 0) {
                # Remove the WAVE path.
                if (!$opt{verbose}) {
                    # Print nothing.
                }
                elsif ($converter->flac->tag('discnumber')) {
                    print sprintf (
                        "! RM [WAVE] %02d-%02d !",
                        $converter->flac->tag('discnumber'),
                        $converter->flac->tag('tracknumber') 
                    );
                }
                else {
                    print sprintf (
                        "! RM [WAVE] %02d !",
                        $converter->flac->tag('tracknumber')
                    );
                }
                $subsystem->exec('rm', $used_wav) == 0
                    or syserr( error => join "\n", 
                                        "Couldn't remove temporary file;",
                                        , basename($used_wav) , $?);
                ;
            }
        }
    };

    while ( $conv_q->pending() 
            || ($USER_HAS_THREADS && threads->list(threads::running) > 0)
            || ($USER_HAS_THREADS && threads->list(threads::joinable) > 0)) {
        if (!$USER_HAS_THREADS) {
            $thread_completion_action->($thread_action->());
            next;
        }
        my $thread_buffer_size = scalar threads->list(threads::running);
        if ( $conv_q->pending() && $thread_buffer_size < $max_threads ) {
            for (0 .. $max_threads - $thread_buffer_size) {
                my $thready = threads->create($thread_action);
            }
        }
        else {
            sleep 1;
        }
        for my $fin_thread (threads->list(threads::joinable)) {
            my $ressy = $fin_thread->join();
            $thread_completion_action->($ressy) if defined $ressy;
        }
    }

    my @remaining_wavs = find_file_pattern('*.wav', '~/.what/work/wav');
    if (@remaining_wavs) {
        if ($opt{'--verbose'}) {
            print map {sprintf ("! RM [WAVE] %s !", $_)} @remaining_wavs;
        }
        $subsystem->exec('rm', @remaining_wavs) == 0
            or syserr( error => "Couldn't remove temporary files;\n"
                                . "@remaining_wavs\n$?");
    }

    print "Done\n";

    # Remove partial releases and quit if a converter thread crashed.
    if ($thread_error) {
        my @rm_partials = 
            ('release-delete', 
                map {
                    file_format_of($_) eq 'MP3' ? "--mp3 $_" : "--$_"
                } @desired_formats );
        print {\*STDERR} "Removing partially transcoded releases.\n";
        $subsystem->exec(@rm_partials) == 0
            or croak("Couldn't remove partially transcoded releases"
                . "@desired_formats.\n");
        exit 1;
    }

    print "Copying accompanying files..." if $opt{'--verbose'};
    for my $dir ($directory->dirs()) {
        my @other_files = $dir->dir_files();
        @other_files 
            = grep {$_ !~ m/\.(?: flac|m3u|cue|log )\z/xms} @other_files;

        # Find an M3U for the directory, and remove for special treatment.
        my @flac_m3us = @{$dir->m3us};
        my $flac_m3u = shift @flac_m3us;
        if (@flac_m3us > 0) {
            print {\*STDERR} 
                "wtf?! multiple M3Us found; $flac_m3u and @flac_m3us\n";
            print {\*STDERR} "skipping @flac_m3us\n";
        }
        if (!defined $flac_m3u && $dir->is_disc) {
            die "No m3u found in FLAC disc directory; $dir->path\n";
        }

        # Copy the other files into the new format directories.
        my $flac_root = $directory->path;
        for my $format (@desired_formats) {
            my $format_ext = format_extension($format);
            my $format_root = $release->format_dir($format);
            my $f_dest
                = $dir->is_root ? $format_root
                : dirname( reroot( $flac_root, $format_root, $dir->path ) );
            if (@other_files > 0) {

                my @cp_others = ('cp', @other_files, $f_dest);
                my $cp_err = $subsystem->exec(@cp_others);
                if ($cp_err) {
                    my @files = map {basename($_)} @other_files;
                    my @err = ("Couldn't copy files to $f_dest", @files);
                    syserr( error => join ("\n", @err, ""), );
                }
            }

            # Write a 'reformated' M3U playlist to the corresponding directory.
            if ($flac_m3u) {
                open my $m3u_in, "<", $flac_m3u
                    or die "Couldn't open playlist $flac_m3u.";
                my $m3u = do {local $/; <$m3u_in>};
                close $m3u_in;

                # Replace '.flac' extensions with the proper extension.
                $m3u =~ s/\.flac ( \r?\n | \z )/\.$format_ext$1/gxms;

                my $format_m3u = reroot($flac_root, $format_root, $flac_m3u);
                open my $m3u_out, ">", $format_m3u
                    or die "Can't write to playlist $format_m3u.";
                print {$m3u_out} $m3u;
                close $m3u_out;
            }
        }
    }
    print "Done\n" if $opt{'--verbose'};

    exit($exitcode);
}

########################################################################
# SUPPORTING SUBROUTINES
########################################################################

# Subroutine: wav_output($flac_file, $wav_dest_dir)
# Type: INTERFACE SUB
# Purpose: 
#   Compute the decoded output file for a given FLAC file.
# Returns: 
#   Path to the decoded WAVE file.
sub wav_output {
    my ($flac, $wav_dir) = @_;
    my $wav_name = basename($flac);
    $wav_name =~ s/ \.flac \z/.wav/xms;
    my $wav_path = "$wav_dir/$wav_name";
    return $wav_path;
}

# Finally, kickstart the script
main();

__END__

=head1 NAME

convert-flac-release
-- Convert a FLAC release to a number of other formats.

=head1 VERSION

Version 0.0_1
Originally created on 07/15/10 01:42:25

=head1 USAGE

convert-flac-release [options]

=head1 REQUIRED ARGUMENTS

=over

=back

=head1 OPTIONS

=over

=item --v0 | --V0

Convert FLAC release to an MP3 V0 VBR release.

=item --v2 | --V2

Convert FLAC release to an MP3 V2 VBR release.

=item --320

Convert FLAC release to an MP3 320kbps CBR release.

=item --ogg | --OGG | --q8

Convert FLAC release to an OGG -q8.0 VBR release.

=item --aac | --AAC

Convert FLAC release to an AAC ~256kbps ABR release.

=item --all

Produce releases in all What.CD allowed formats and bitrates (not recommended).

=item --mp3 <quality> | --MP3 <quality>

Specify creation of CBR bitrate or VBR quality release. 
<quality> can be any of the following:

    32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320

or 

    V1, V2, V3, V4, V5, V6, V7, V8, V9

=for Euclid:
    repeatable
    quality.type: string, quality =~ m/[vV][0-9]|32|40|48|56|64|80|96|112|128|160|192|224|256|320/

=item --force-flac | -f

Force flac to overwrite any existing WAVE files.

=item --dry-run

Do not actually run any programs. Just print out commands.

=item --verbose

Print out commands prior to execution.

=item --version

=item --usage

=item --help

=item --man

Print the usual program information

=back

=head1 DESCRIPTION

Transcode the FLAC files of the context-release directory and create
releases of other formats.

=head1 BUGS

=over

Known to not properly transfer foreign language characters in song tags.

=back

=head1 COPYRIGHT & LICENSE

© The What team.

This file is part of What.

What is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

What is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with What.  If not, see <http://www.gnu.org/licenses/>.

=cut

